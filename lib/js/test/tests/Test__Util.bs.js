// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Os = require("os");
var Caml = require("rescript/lib/js/caml.js");
var Diff = require("diff");
var Util = require("util");
var Assert = require("assert");
var Vscode = require("vscode");
var Nodefs = require("node:fs");
var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Nodepath = require("node:path");
var Js_promise = require("rescript/lib/js/js_promise.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Chan$AgdaModeVscode = require("../../src/Util/Chan.bs.js");
var Main$AgdaModeVscode = require("../../src/Main.bs.js");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Config$AgdaModeVscode = require("../../src/Config.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Node__Fs$AgdaModeVscode = require("../../src/Node/Node__Fs.bs.js");
var Source$LanguageServerMule = require("language-server-mule/lib/js/src/Source.bs.js");
var Connection__Error$AgdaModeVscode = require("../../src/Connection/Connection__Error.bs.js");
var Connection__Emacs__Error$AgdaModeVscode = require("../../src/Connection/Emacs/Connection__Emacs__Error.bs.js");

var Exn = /* @__PURE__ */Caml_exceptions.create("Test__Util-AgdaModeVscode.Exn");

var runner = (function(f) {
    var tmp
    try {
      var result = f();
      tmp = {
        TAG: 0,
        _0: result,
        [Symbol.for("name")]: "Ok"
      };
    }
    catch (raw_exn){
      tmp = 
        {
          TAG: 1,
          _0: raw_exn,
          [Symbol.for("name")]: "Error"
        };
    }
    return $$Promise.resolved(tmp);
  });

function toAbsolute(filepath) {
  return Nodepath.resolve(__dirname, filepath);
}

var extensionPath = Nodepath.resolve(__dirname, "../../../../");

var globalStoragePath = Nodepath.resolve(__dirname, "../../../../test/globalStoragePath");

function asset(filepath) {
  return Nodepath.join(extensionPath, "test/tests/assets", filepath);
}

var Path = {
  toAbsolute: toAbsolute,
  extensionPath: extensionPath,
  globalStoragePath: globalStoragePath,
  asset: asset
};

var activationSingleton = {
  contents: undefined
};

function activateExtension() {
  var channels = activationSingleton.contents;
  if (channels !== undefined) {
    return channels;
  }
  var disposables = [];
  var channels$1 = Main$AgdaModeVscode.activateWithoutContext(disposables, extensionPath, globalStoragePath);
  activationSingleton.contents = channels$1;
  return channels$1;
}

function openFile(fileName) {
  return Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined);
}

async function activateExtensionAndOpenFile(fileName) {
  var channels = activateExtension();
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined);
  return [
          editor,
          channels
        ];
}

function wait(ms) {
  return new Promise((function (resolve, param) {
                setTimeout(resolve, ms);
              }));
}

function normalize(string) {
  return Js_string.replaceByRe(/\r\n|\n/g, "\n", string.trim());
}

function unlinesWith(f, xs) {
  return Util$AgdaModeVscode.$$String.unlines(xs.map(f));
}

function breakInput(input, breakpoints) {
  var breakpoints$p = [0].concat(breakpoints);
  return breakpoints$p.map(function (x, i) {
                var next = breakpoints$p[i + 1 | 0];
                if (next !== undefined) {
                  return [
                          x,
                          next - x | 0
                        ];
                } else {
                  return [
                          x,
                          input.length - x | 0
                        ];
                }
              }).map(function (param) {
              return Js_string.substrAtMost(param[0], param[1], input);
            });
}

var Strings = {
  normalize: normalize,
  unlinesWith: unlinesWith,
  breakInput: breakInput
};

function getValue(x) {
  return x._0;
}

function fromChangeObject(obj) {
  if (obj.added) {
    return {
            TAG: "Added",
            _0: obj.value,
            [Symbol.for("name")]: "Added"
          };
  } else if (obj.removed) {
    return {
            TAG: "Removed",
            _0: obj.value,
            [Symbol.for("name")]: "Removed"
          };
  } else {
    return {
            TAG: "NoChange",
            _0: obj.value,
            [Symbol.for("name")]: "NoChange"
          };
  }
}

function wordsWithSpace(a, b) {
  return Diff.diffWordsWithSpace(a, b).map(fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  diffs.forEach(function (diff) {
        if (!Core__Option.isNone(change.contents)) {
          return ;
        }
        switch (diff.TAG) {
          case "Added" :
              change.contents = {
                TAG: "Added",
                _0: diff._0,
                [Symbol.for("name")]: "Added"
              };
              return ;
          case "Removed" :
              change.contents = {
                TAG: "Removed",
                _0: diff._0,
                [Symbol.for("name")]: "Removed"
              };
              return ;
          case "NoChange" :
              count.contents = count.contents + diff._0.length | 0;
              return ;
          
        }
      });
  return Core__Option.map(change.contents, (function (change) {
                return [
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(directoryPath) {
  var directoryPath$1 = Nodepath.resolve(__dirname, directoryPath);
  var readdir = function (extra) {
    return Util.promisify((function (prim0, prim1) {
                  Fs.readdir(prim0, prim1);
                }), extra);
  };
  var isInFile = function (x) {
    return Js_string.endsWith(".in", x);
  };
  var toBasename = function (path) {
    return Nodepath.join(directoryPath$1, Nodepath.basename(path, ".in"));
  };
  return Js_promise.then_((function (paths) {
                return Promise.resolve(paths.filter(isInFile).map(toBasename));
              }), readdir(directoryPath$1));
}

function getGoldenFilepathsSync(directoryPath) {
  var directoryPath$1 = Nodepath.resolve(__dirname, directoryPath);
  var isInFile = function (x) {
    return Js_string.endsWith(".in", x);
  };
  var toBasename = function (path) {
    return Nodepath.join(directoryPath$1, Nodepath.basename(path, ".in"));
  };
  return Nodefs.readdirSync(directoryPath$1).filter(isInFile).map(toBasename);
}

var FileMissing = /* @__PURE__ */Caml_exceptions.create("Test__Util-AgdaModeVscode.Golden.FileMissing");

function toString(param) {
  return "Golden file at: " + param._0 + "\nExpected: \n" + param._2 + "\nActual: \n" + param._1;
}

function map(param, f) {
  return {
          TAG: "Golden",
          _0: param._0,
          _1: f(param._1),
          _2: param._2,
          [Symbol.for("name")]: "Golden"
        };
}

async function readFile(filepath) {
  var filepath$1 = Nodepath.resolve(__dirname, filepath);
  var inFile = await Node__Fs$AgdaModeVscode.readFile(filepath$1 + ".in");
  var outFile = await Node__Fs$AgdaModeVscode.readFile(filepath$1 + ".out");
  return {
          TAG: "Golden",
          _0: filepath$1,
          _1: inFile,
          _2: outFile,
          [Symbol.for("name")]: "Golden"
        };
}

function compare(param) {
  var actual = normalize(param._1);
  var expected = normalize(param._2);
  Core__Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff._0;
          var change = value.length > 100 ? Js_string.substrAtMost(0, 100, value) + " ..." : value;
          var expected$1 = Js_string.substrAtMost(Caml.int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0, expected);
          var actual$1 = Js_string.substrAtMost(Caml.int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0, actual);
          var message = function (change) {
            return "\n\nchange => " + change + "\n\nexpected => " + expected$1 + "\n\nactual   => " + actual$1;
          };
          switch (diff.TAG) {
            case "Added" :
            case "Removed" :
                Assert.fail(message(change));
                return ;
            case "NoChange" :
                return ;
            
          }
        }));
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  toString: toString,
  map: map,
  readFile: readFile,
  compare: compare
};

var match = Os.type();

var onUnix = match === "Windows_NT" ? false : true;

function toString$1(x) {
  if (x.TAG === "LanguageServerMuleErrors") {
    return Js_array.joinWith(",", x._0.map(Source$LanguageServerMule.$$Error.toString));
  }
  var match = Connection__Emacs__Error$AgdaModeVscode.toString(x._0);
  return "EmacsConnectionError: " + match[0] + ": " + match[1];
}

var $$Error = {
  toString: toString$1
};

async function exists(command) {
  var match = await Source$LanguageServerMule.Module.searchUntilSuccess([{
          TAG: "FromCommand",
          _0: command,
          [Symbol.for("name")]: "FromCommand"
        }]);
  if (match[0] !== undefined) {
    return ;
  }
  var msg = Js_array.joinWith(",", match[1].map(Source$LanguageServerMule.$$Error.toString));
  throw {
        RE_EXN_ID: "Failure",
        _1: "Cannot find \"agda\" in PATH: " + msg,
        Error: new Error()
      };
}

async function makeAndLoad(alsOpt, filepath) {
  var als = alsOpt !== undefined ? alsOpt : false;
  var filepath$1 = asset(filepath);
  Config$AgdaModeVscode.inTestingMode.contents = true;
  await Config$AgdaModeVscode.Connection.setAgdaVersion("agda");
  await Config$AgdaModeVscode.Connection.setUseAgdaLanguageServer(als);
  await exists("agda");
  var load = async function (channels, filepath) {
    var match = Util$AgdaModeVscode.Promise_.pending();
    var resolve = match[1];
    var disposable = Chan$AgdaModeVscode.on(channels.responseHandled, (function (response) {
            if (typeof response !== "object" && response === "CompleteHighlightingAndMakePromptReappear") {
              return resolve();
            }
            
          }));
    await Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined);
    var match$1 = await Vscode.commands.executeCommand("agda-mode.load");
    if (match$1 !== undefined) {
      if (match$1.TAG === "Ok") {
        await match[0];
        disposable();
        return match$1._0;
      }
      var match$2 = Connection__Error$AgdaModeVscode.toString(match$1._0);
      throw {
            RE_EXN_ID: "Failure",
            _1: match$2[0] + "\n" + match$2[1],
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "Cannot load " + filepath,
          Error: new Error()
        };
  };
  var channels = activateExtension();
  var state = await load(channels, filepath$1);
  return {
          filepath: filepath$1,
          channels: channels,
          state: state
        };
}

async function $$case(self, cursorAndPayload) {
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined);
  if (cursorAndPayload !== undefined) {
    var cursor = cursorAndPayload[0];
    var succeed = await Editor$AgdaModeVscode.$$Text.insert(self.state.document, cursor, cursorAndPayload[1]);
    if (!succeed) {
      throw {
            RE_EXN_ID: "Failure",
            _1: "Failed to insert text",
            Error: new Error()
          };
    }
    Editor$AgdaModeVscode.Cursor.set(editor, cursor);
  }
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var destructor = Chan$AgdaModeVscode.on(self.state.channels.commandHandled, (function (command) {
          if (typeof command !== "object" && command === "Load") {
            return resolve();
          }
          
        }));
  var match$1 = await Vscode.commands.executeCommand("agda-mode.case");
  if (match$1 !== undefined) {
    if (match$1.TAG === "Ok") {
      await match[0];
      destructor();
      self.state = match$1._0;
      return ;
    }
    var match$2 = Connection__Error$AgdaModeVscode.toString(match$1._0);
    throw {
          RE_EXN_ID: "Failure",
          _1: match$2[0] + "\n" + match$2[1],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Cannot case split " + self.filepath,
        Error: new Error()
      };
}

async function refine(self, cursorAndPayload, state) {
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined);
  if (cursorAndPayload !== undefined) {
    var payload = cursorAndPayload[1];
    var cursor = cursorAndPayload[0];
    if (payload !== undefined) {
      await Editor$AgdaModeVscode.$$Text.insert(state.document, cursor, payload);
      Editor$AgdaModeVscode.Cursor.set(editor, cursor);
    } else {
      Editor$AgdaModeVscode.Cursor.set(editor, cursor);
    }
  }
  var match = await Vscode.commands.executeCommand("agda-mode.refine");
  if (match !== undefined) {
    if (match.TAG === "Ok") {
      return match._0;
    }
    var match$1 = Connection__Error$AgdaModeVscode.toString(match._0);
    throw {
          RE_EXN_ID: "Failure",
          _1: match$1[0] + "\n" + match$1[1],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Cannot case refine " + self.filepath,
        Error: new Error()
      };
}

var AgdaMode = {
  $$Error: $$Error,
  exists: exists,
  makeAndLoad: makeAndLoad,
  $$case: $$case,
  refine: refine
};

async function readFile$1(filepath, $$var) {
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined);
  $$var.contents = Editor$AgdaModeVscode.$$Text.getAll(editor.document);
}

async function restoreFile(filepath, $$var) {
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined);
  var $$document = editor.document;
  var lineCount = $$document.lineCount;
  var replaceRange = new Vscode.Range(new Vscode.Position(0, 0), new Vscode.Position(lineCount, 0));
  var succeed = await Editor$AgdaModeVscode.$$Text.replace($$document, replaceRange, $$var.contents);
  if (succeed) {
    await $$document.save();
    return ;
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Failed to restore the file",
        Error: new Error()
      };
}

function unwrap(x) {
  if (x.TAG === "Ok") {
    return x._0;
  }
  throw x._0;
}

var R = {
  unwrap: unwrap
};

async function unwrap$1(promise) {
  var result = await promise;
  return unwrap(result);
}

var P = {
  unwrap: unwrap$1
};

exports.Exn = Exn;
exports.runner = runner;
exports.Path = Path;
exports.activationSingleton = activationSingleton;
exports.activateExtension = activateExtension;
exports.openFile = openFile;
exports.activateExtensionAndOpenFile = activateExtensionAndOpenFile;
exports.wait = wait;
exports.Strings = Strings;
exports.Golden = Golden;
exports.onUnix = onUnix;
exports.AgdaMode = AgdaMode;
exports.readFile = readFile$1;
exports.restoreFile = restoreFile;
exports.R = R;
exports.P = P;
/* extensionPath Not a pure module */
