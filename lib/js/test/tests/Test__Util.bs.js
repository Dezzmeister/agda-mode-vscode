// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Os = require("os");
var Caml = require("rescript/lib/js/caml.js");
var Diff = require("diff");
var Util = require("util");
var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Nodefs = require("node:fs");
var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Nodepath = require("node:path");
var Js_promise = require("rescript/lib/js/js_promise.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Chan$AgdaModeVscode = require("../../src/Util/Chan.bs.js");
var Main$AgdaModeVscode = require("../../src/Main.bs.js");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Config$AgdaModeVscode = require("../../src/Config.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Node__Fs$AgdaModeVscode = require("../../src/Node/Node__Fs.bs.js");
var Source$LanguageServerMule = require("language-server-mule/lib/js/src/Source.bs.js");
var Connection__Error$AgdaModeVscode = require("../../src/Connection/Connection__Error.bs.js");
var Connection__Emacs__Error$AgdaModeVscode = require("../../src/Connection/Emacs/Connection__Emacs__Error.bs.js");

var Exn = /* @__PURE__ */Caml_exceptions.create("Test__Util-AgdaModeVscode.Exn");

var runner = (function(f) {
    var tmp
    try {
      var result = f();
      tmp = {
        TAG: 0,
        _0: result,
        [Symbol.for("name")]: "Ok"
      };
    }
    catch (raw_exn){
      tmp = 
        {
          TAG: 1,
          _0: raw_exn,
          [Symbol.for("name")]: "Error"
        };
    }
    return $$Promise.resolved(tmp);
  });

function toAbsolute(filepath) {
  return Nodepath.resolve(__dirname, filepath);
}

var extensionPath = Nodepath.resolve(__dirname, "../../../../");

var globalStoragePath = Nodepath.resolve(__dirname, "../../../../test/globalStoragePath");

function asset(filepath) {
  return Nodepath.join(extensionPath, "test/tests/assets", filepath);
}

var Path = {
  toAbsolute: toAbsolute,
  extensionPath: extensionPath,
  globalStoragePath: globalStoragePath,
  asset: asset
};

var activationSingleton = {
  contents: undefined
};

function activateExtension() {
  var channels = activationSingleton.contents;
  if (channels !== undefined) {
    return channels;
  }
  var disposables = [];
  var channels$1 = Main$AgdaModeVscode.activateWithoutContext(disposables, extensionPath, globalStoragePath);
  activationSingleton.contents = channels$1;
  return channels$1;
}

function openFile(fileName) {
  return Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined);
}

async function activateExtensionAndOpenFile(fileName) {
  var channels = activateExtension();
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined);
  return [
          editor,
          channels
        ];
}

function wait(ms) {
  return new Promise((function (resolve, param) {
                setTimeout(resolve, ms);
              }));
}

function toPromise(f) {
  return new Promise((function (resolve, reject) {
                f.then(function (x) {
                      if (x.TAG === "Ok") {
                        return resolve(x._0);
                      } else {
                        return reject(x._0);
                      }
                    });
              }));
}

function it$1(s, f) {
  it(s, (function () {
          return toPromise(f());
        }));
}

function it_only(s, f) {
  it.only(s, (function () {
          return toPromise(f());
        }));
}

function it_skip(s, f) {
  it.skip(s, (function () {
          return toPromise(f());
        }));
}

function before$1(f) {
  before(function () {
        return toPromise(f());
      });
}

function before_each(f) {
  beforeEach(function () {
        return toPromise(f());
      });
}

function after$1(f) {
  after(function () {
        return toPromise(f());
      });
}

function after_each(f) {
  afterEach(function () {
        return toPromise(f());
      });
}

var Q = {
  toPromise: toPromise,
  it: it$1,
  it_only: it_only,
  it_skip: it_skip,
  before: before$1,
  before_each: before_each,
  after: after$1,
  after_each: after_each
};

function equal(expected, actual) {
  return runner(function () {
              Curry._3(Assert.equal, actual, expected, undefined);
            });
}

function deepEqual(expected, actual) {
  return runner(function () {
              Curry._3(Assert.deepEqual, actual, expected, undefined);
            });
}

function deep_strict_equal(expected, actual) {
  return runner(function () {
              Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
            });
}

function fail(value) {
  return runner(function () {
              Assert.fail(value);
            });
}

var A = {
  equal: equal,
  deepEqual: deepEqual,
  deep_strict_equal: deep_strict_equal,
  fail: fail
};

function normalize(string) {
  return Js_string.replaceByRe(/\r\n|\n/g, "\n", string.trim());
}

function unlinesWith(f, xs) {
  return Util$AgdaModeVscode.$$String.unlines(xs.map(f));
}

function breakInput(input, breakpoints) {
  var breakpoints$p = [0].concat(breakpoints);
  return breakpoints$p.map(function (x, i) {
                var next = breakpoints$p[i + 1 | 0];
                if (next !== undefined) {
                  return [
                          x,
                          next - x | 0
                        ];
                } else {
                  return [
                          x,
                          input.length - x | 0
                        ];
                }
              }).map(function (param) {
              return Js_string.substrAtMost(param[0], param[1], input);
            });
}

var Strings = {
  normalize: normalize,
  unlinesWith: unlinesWith,
  breakInput: breakInput
};

function getValue(x) {
  return x._0;
}

function fromChangeObject(obj) {
  if (obj.added) {
    return {
            TAG: "Added",
            _0: obj.value,
            [Symbol.for("name")]: "Added"
          };
  } else if (obj.removed) {
    return {
            TAG: "Removed",
            _0: obj.value,
            [Symbol.for("name")]: "Removed"
          };
  } else {
    return {
            TAG: "NoChange",
            _0: obj.value,
            [Symbol.for("name")]: "NoChange"
          };
  }
}

function wordsWithSpace(a, b) {
  return Diff.diffWordsWithSpace(a, b).map(fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  diffs.forEach(function (diff) {
        if (!Core__Option.isNone(change.contents)) {
          return ;
        }
        switch (diff.TAG) {
          case "Added" :
              change.contents = {
                TAG: "Added",
                _0: diff._0,
                [Symbol.for("name")]: "Added"
              };
              return ;
          case "Removed" :
              change.contents = {
                TAG: "Removed",
                _0: diff._0,
                [Symbol.for("name")]: "Removed"
              };
              return ;
          case "NoChange" :
              count.contents = count.contents + diff._0.length | 0;
              return ;
          
        }
      });
  return Core__Option.map(change.contents, (function (change) {
                return [
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(directoryPath) {
  var directoryPath$1 = Nodepath.resolve(__dirname, directoryPath);
  var readdir = function (extra) {
    return Util.promisify((function (prim0, prim1) {
                  Fs.readdir(prim0, prim1);
                }), extra);
  };
  var isInFile = function (x) {
    return Js_string.endsWith(".in", x);
  };
  var toBasename = function (path) {
    return Nodepath.join(directoryPath$1, Nodepath.basename(path, ".in"));
  };
  return Js_promise.then_((function (paths) {
                return Promise.resolve(paths.filter(isInFile).map(toBasename));
              }), readdir(directoryPath$1));
}

function getGoldenFilepathsSync(directoryPath) {
  var directoryPath$1 = Nodepath.resolve(__dirname, directoryPath);
  var isInFile = function (x) {
    return Js_string.endsWith(".in", x);
  };
  var toBasename = function (path) {
    return Nodepath.join(directoryPath$1, Nodepath.basename(path, ".in"));
  };
  return Nodefs.readdirSync(directoryPath$1).filter(isInFile).map(toBasename);
}

var FileMissing = /* @__PURE__ */Caml_exceptions.create("Test__Util-AgdaModeVscode.Golden.FileMissing");

function toString(param) {
  return "Golden file at: " + param._0 + "\nExpected: \n" + param._2 + "\nActual: \n" + param._1;
}

function map(param, f) {
  return {
          TAG: "Golden",
          _0: param._0,
          _1: f(param._1),
          _2: param._2,
          [Symbol.for("name")]: "Golden"
        };
}

async function readFile(filepath) {
  var filepath$1 = Nodepath.resolve(__dirname, filepath);
  var inFile = await Node__Fs$AgdaModeVscode.readFile(filepath$1 + ".in");
  var outFile = await Node__Fs$AgdaModeVscode.readFile(filepath$1 + ".out");
  return {
          TAG: "Golden",
          _0: filepath$1,
          _1: inFile,
          _2: outFile,
          [Symbol.for("name")]: "Golden"
        };
}

function compare(param) {
  var actual = normalize(param._1);
  var expected = normalize(param._2);
  Core__Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff._0;
          var change = value.length > 100 ? Js_string.substrAtMost(0, 100, value) + " ..." : value;
          var expected$1 = Js_string.substrAtMost(Caml.int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0, expected);
          var actual$1 = Js_string.substrAtMost(Caml.int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0, actual);
          var message = function (change) {
            return "\n\nchange => " + change + "\n\nexpected => " + expected$1 + "\n\nactual   => " + actual$1;
          };
          switch (diff.TAG) {
            case "Added" :
            case "Removed" :
                Assert.fail(message(change));
                return ;
            case "NoChange" :
                return ;
            
          }
        }));
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  toString: toString,
  map: map,
  readFile: readFile,
  compare: compare
};

var match = Os.type();

var onUnix = match === "Windows_NT" ? false : true;

function toString$1(x) {
  if (x.TAG === "LanguageServerMuleErrors") {
    return Js_array.joinWith(",", x._0.map(Source$LanguageServerMule.$$Error.toString));
  }
  var match = Connection__Emacs__Error$AgdaModeVscode.toString(x._0);
  return "EmacsConnectionError: " + match[0] + ": " + match[1];
}

var $$Error = {
  toString: toString$1
};

async function exists(command) {
  var match = await Source$LanguageServerMule.Module.searchUntilSuccess([{
          TAG: "FromCommand",
          _0: command,
          [Symbol.for("name")]: "FromCommand"
        }]);
  if (match[0] !== undefined) {
    return {
            TAG: "Ok",
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  }
  var msg = Js_array.joinWith(",", match[1].map(Source$LanguageServerMule.$$Error.toString));
  return await fail("Cannot find \"Agda\" in PATH: " + msg);
}

async function make(alsOpt, filepath) {
  var als = alsOpt !== undefined ? alsOpt : false;
  var filepath$1 = asset(filepath);
  Config$AgdaModeVscode.inTestingMode.contents = true;
  await Config$AgdaModeVscode.Connection.setAgdaVersion("agda");
  await Config$AgdaModeVscode.Connection.setUseAgdaLanguageServer(als);
  await exists("agda");
  return {
          filepath: filepath$1,
          channels: activateExtension()
        };
}

async function load(self) {
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var disposable = Chan$AgdaModeVscode.on(self.channels.responseHandled, (function (response) {
          if (typeof response !== "object" && response === "CompleteHighlightingAndMakePromptReappear") {
            return resolve();
          }
          
        }));
  await Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined);
  var match$1 = await Vscode.commands.executeCommand("agda-mode.load");
  if (match$1 === undefined) {
    return await fail("Cannot load " + self.filepath);
  }
  if (match$1.TAG === "Ok") {
    await match[0];
    disposable();
    return {
            TAG: "Ok",
            _0: [
              self,
              match$1._0
            ],
            [Symbol.for("name")]: "Ok"
          };
  }
  var match$2 = Connection__Error$AgdaModeVscode.toString(match$1._0);
  return await fail(match$2[0] + "\n" + match$2[1]);
}

async function $$case(cursorAndPayload, param) {
  var self = param[0];
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined);
  if (cursorAndPayload !== undefined) {
    var cursor = cursorAndPayload[0];
    await Editor$AgdaModeVscode.$$Text.insert(param[1].document, cursor, cursorAndPayload[1]);
    Editor$AgdaModeVscode.Cursor.set(editor, cursor);
  }
  var match = await Vscode.commands.executeCommand("agda-mode.case");
  if (match === undefined) {
    return await fail("Cannot case split " + self.filepath);
  }
  if (match.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              self,
              match._0
            ],
            [Symbol.for("name")]: "Ok"
          };
  }
  var match$1 = Connection__Error$AgdaModeVscode.toString(match._0);
  return await fail(match$1[0] + "\n" + match$1[1]);
}

async function refine(cursorAndPayload, param) {
  var self = param[0];
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined);
  if (cursorAndPayload !== undefined) {
    var payload = cursorAndPayload[1];
    var cursor = cursorAndPayload[0];
    if (payload !== undefined) {
      await Editor$AgdaModeVscode.$$Text.insert(param[1].document, cursor, payload);
      Editor$AgdaModeVscode.Cursor.set(editor, cursor);
    } else {
      Editor$AgdaModeVscode.Cursor.set(editor, cursor);
    }
  }
  var match = await Vscode.commands.executeCommand("agda-mode.refine");
  if (match === undefined) {
    return await fail("Cannot case refine " + self.filepath);
  }
  if (match.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              self,
              match._0
            ],
            [Symbol.for("name")]: "Ok"
          };
  }
  var match$1 = Connection__Error$AgdaModeVscode.toString(match._0);
  return await fail(match$1[0] + "\n" + match$1[1]);
}

var Agda = {
  $$Error: $$Error,
  exists: exists,
  make: make,
  load: load,
  $$case: $$case,
  refine: refine
};

async function readFile$1(filepath, $$var) {
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined);
  $$var.contents = Editor$AgdaModeVscode.$$Text.getAll(editor.document);
  return {
          TAG: "Ok",
          _0: undefined,
          [Symbol.for("name")]: "Ok"
        };
}

async function restoreFile(filepath, $$var) {
  var editor = await Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined);
  var $$document = editor.document;
  var lineCount = $$document.lineCount;
  var replaceRange = new Vscode.Range(new Vscode.Position(0, 0), new Vscode.Position(lineCount, 0));
  await Editor$AgdaModeVscode.$$Text.replace($$document, replaceRange, $$var.contents);
  await $$document.save();
  return {
          TAG: "Ok",
          _0: undefined,
          [Symbol.for("name")]: "Ok"
        };
}

function unwrap(x) {
  if (x.TAG === "Ok") {
    return x._0;
  }
  throw x._0;
}

var R = {
  unwrap: unwrap
};

async function unwrap$1(promise) {
  var result = await promise;
  return unwrap(result);
}

var P = {
  unwrap: unwrap$1
};

exports.Exn = Exn;
exports.runner = runner;
exports.Path = Path;
exports.activationSingleton = activationSingleton;
exports.activateExtension = activateExtension;
exports.openFile = openFile;
exports.activateExtensionAndOpenFile = activateExtensionAndOpenFile;
exports.wait = wait;
exports.Q = Q;
exports.A = A;
exports.Strings = Strings;
exports.Golden = Golden;
exports.onUnix = onUnix;
exports.Agda = Agda;
exports.readFile = readFile$1;
exports.restoreFile = restoreFile;
exports.R = R;
exports.P = P;
/* extensionPath Not a pure module */
