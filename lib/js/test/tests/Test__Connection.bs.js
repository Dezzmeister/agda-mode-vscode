// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Connection$AgdaModeVscode = require("../../src/Connection/Connection.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var State__Memento$AgdaModeVscode = require("../../src/State/State__Memento.bs.js");
var Connection__Target$AgdaModeVscode = require("../../src/Connection/Connection__Target.bs.js");
var Connection__Command__Search$AgdaModeVscode = require("../../src/Connection/Connection__Command__Search.bs.js");

describe("Connection", (function () {
        describe("Target", (function () {
                var agdaMockPath = {
                  contents: ""
                };
                var agdaMockTarget = {
                  contents: undefined
                };
                before(async function () {
                      agdaMockPath.contents = await Test__Util$AgdaModeVscode.Target.Agda.mock("2.7.0.1", "agda-mock");
                      var target = await Connection__Target$AgdaModeVscode.fromRawPath(agdaMockPath.contents);
                      if (target.TAG === "Ok") {
                        agdaMockTarget.contents = target._0;
                        return ;
                      } else {
                        return PervasivesU.failwith("Got error when trying to construct a mock for Agda");
                      }
                    });
                it("should return the previously picked connection", (async function () {
                        var target = agdaMockTarget.contents;
                        var agdaMockTarget$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        await Connection__Target$AgdaModeVscode.setPicked(memento, agdaMockTarget$1);
                        var paths = [
                          agdaMockPath.contents,
                          "path/to/als"
                        ];
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        var expected = agdaMockTarget$1;
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                it("should return nothing when there's no previously picked connection", (async function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [
                          "path/to/agda",
                          "path/to/als"
                        ];
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        return Curry._3(Assert.deepEqual, actual, undefined, undefined);
                      }));
                it("should return nothing when the previously picked connection is not in the supplied paths", (async function () {
                        var target = agdaMockTarget.contents;
                        var agdaMockTarget$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        await Connection__Target$AgdaModeVscode.setPicked(memento, agdaMockTarget$1);
                        var paths = [
                          "path/to/agda",
                          "path/to/als"
                        ];
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        return Curry._3(Assert.deepEqual, actual, undefined, undefined);
                      }));
                after(async function () {
                      var target = agdaMockTarget.contents;
                      if (target !== undefined) {
                        Test__Util$AgdaModeVscode.Target.Agda.destroy(target);
                        agdaMockTarget.contents = undefined;
                        return ;
                      }
                      
                    });
              }));
        describe("Command searching", (function () {
                it("should return the connection when the command is found", (async function () {
                        var _output = await Connection__Command__Search$AgdaModeVscode.search("ls", undefined);
                        if (_output.TAG === "Ok") {
                          return ;
                        } else {
                          return PervasivesU.failwith("expected to find `ls`");
                        }
                      }));
                it("should return an error when the command is not found", (async function () {
                        var _output = await Connection__Command__Search$AgdaModeVscode.search("non-existent-command", undefined);
                        if (_output.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
        describe("findCommands", (function () {
                it("should return the connection when the command is found", (async function () {
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var match = await Connection$AgdaModeVscode.findCommands(commands);
                        if (match.TAG === "Ok") {
                          return ;
                        } else {
                          return PervasivesU.failwith("expected to find `agda` or `als`");
                        }
                      }));
                it("should return an error when the command is not found", (async function () {
                        var commands = ["non-existent-command"];
                        var match = await Connection$AgdaModeVscode.findCommands(commands);
                        if (match.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
      }));

/*  Not a pure module */
