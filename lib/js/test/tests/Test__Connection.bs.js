// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Nodeurl = require("node:url");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var OS$AgdaModeVscode = require("../../src/Util/OS.bs.js");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Config$AgdaModeVscode = require("../../src/Config.bs.js");
var Connection$AgdaModeVscode = require("../../src/Connection/Connection.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var State__Memento$AgdaModeVscode = require("../../src/State/State__Memento.bs.js");
var Connection__URI$AgdaModeVscode = require("../../src/Connection/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("../../src/Connection/Connection__Error.bs.js");
var Connection__Target$AgdaModeVscode = require("../../src/Connection/Connection__Target.bs.js");
var Connection__Command$AgdaModeVscode = require("../../src/Connection/Connection__Command.bs.js");
var Connection__Download__Platform$AgdaModeVscode = require("../../src/Connection/Download/Connection__Download__Platform.bs.js");

describe("Connection", (function () {
        describe("URI.parse", (function () {
                it("should be able to parse URIs with lsp: as the protocol", (async function () {
                        var actual = Connection__URI$AgdaModeVscode.parse("lsp://path/to/als");
                        var expected = {
                          TAG: "URL",
                          _0: new Nodeurl.URL("lsp://path/to/als"),
                          [Symbol.for("name")]: "URL"
                        };
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                it("should be able to parse file paths", (async function () {
                        var actual = Connection__URI$AgdaModeVscode.parse("path/to/als");
                        var expected = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Filepath",
                              _0: "path/to/als",
                              [Symbol.for("name")]: "Filepath"
                            }) : ({
                              TAG: "Filepath",
                              _0: "path\\to\\als",
                              [Symbol.for("name")]: "Filepath"
                            });
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                it("should be able to parse convert \"/c/path/to/agda\" to \"c:/path/to/agda\" on Windows", (async function () {
                        var actual = Connection__URI$AgdaModeVscode.parse("/c/path/to/agda");
                        var expected = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Filepath",
                              _0: "/c/path/to/agda",
                              [Symbol.for("name")]: "Filepath"
                            }) : ({
                              TAG: "Filepath",
                              _0: "c:\\path\\to\\agda",
                              [Symbol.for("name")]: "Filepath"
                            });
                        Curry._3(Assert.deepEqual, actual, expected, undefined);
                        var actual$1 = Connection__URI$AgdaModeVscode.parse("/d/path/to/agda");
                        var expected$1 = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Filepath",
                              _0: "/d/path/to/agda",
                              [Symbol.for("name")]: "Filepath"
                            }) : ({
                              TAG: "Filepath",
                              _0: "d:\\path\\to\\agda",
                              [Symbol.for("name")]: "Filepath"
                            });
                        return Curry._3(Assert.deepEqual, actual$1, expected$1, undefined);
                      }));
              }));
        describe("Target", (function () {
                var agdaMockPath = {
                  contents: ""
                };
                var agdaMockTarget = {
                  contents: undefined
                };
                before(async function () {
                      agdaMockPath.contents = await Test__Util$AgdaModeVscode.Target.Agda.mock("2.7.0.1", "agda-mock");
                      var target = await Connection__Target$AgdaModeVscode.fromRawPath(agdaMockPath.contents);
                      if (target.TAG === "Ok") {
                        agdaMockTarget.contents = target._0;
                        return ;
                      } else {
                        return PervasivesU.failwith("Got error when trying to construct a mock for Agda ");
                      }
                    });
                it("should return the previously picked connection", (async function () {
                        var target = agdaMockTarget.contents;
                        var agdaMockTarget$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        await Connection__Target$AgdaModeVscode.setPicked(memento, agdaMockTarget$1);
                        var paths = [
                            agdaMockPath.contents,
                            "path/to/als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        var expected = {
                          TAG: "Ok",
                          _0: agdaMockTarget$1,
                          [Symbol.for("name")]: "Ok"
                        };
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                it("should return nothing when there's no previously picked connection", (async function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [
                            "path/to/agda",
                            "path/to/als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        var expected = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Error",
                              _0: [
                                {
                                  TAG: "ValidationError",
                                  _0: "path/to/agda",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path/to/agda",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                },
                                {
                                  TAG: "ValidationError",
                                  _0: "path/to/als",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path/to/als",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                }
                              ],
                              [Symbol.for("name")]: "Error"
                            }) : ({
                              TAG: "Error",
                              _0: [
                                {
                                  TAG: "ValidationError",
                                  _0: "path\\to\\agda",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path\\to\\agda",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                },
                                {
                                  TAG: "ValidationError",
                                  _0: "path\\to\\als",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path\\to\\als",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                }
                              ],
                              [Symbol.for("name")]: "Error"
                            });
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                it("should return nothing when the previously picked connection is not in the supplied paths", (async function () {
                        var target = agdaMockTarget.contents;
                        var agdaMockTarget$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        await Connection__Target$AgdaModeVscode.setPicked(memento, agdaMockTarget$1);
                        var paths = [
                            "path/to/agda",
                            "path/to/als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        var expected = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Error",
                              _0: [
                                {
                                  TAG: "ValidationError",
                                  _0: "path/to/agda",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path/to/agda",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                },
                                {
                                  TAG: "ValidationError",
                                  _0: "path/to/als",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path/to/als",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                }
                              ],
                              [Symbol.for("name")]: "Error"
                            }) : ({
                              TAG: "Error",
                              _0: [
                                {
                                  TAG: "ValidationError",
                                  _0: "path\\to\\agda",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path\\to\\agda",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                },
                                {
                                  TAG: "ValidationError",
                                  _0: "path\\to\\als",
                                  _1: {
                                    TAG: "NotFound",
                                    _0: "path\\to\\als",
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "ValidationError"
                                }
                              ],
                              [Symbol.for("name")]: "Error"
                            });
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                it("should return the first usable connection target when the previously picked connection is invalid or not in the supplied paths", (async function () {
                        var target = agdaMockTarget.contents;
                        var agdaMockTarget$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [
                            "path/to/non-existent-agda",
                            agdaMockPath.contents,
                            "path/to/non-existent-als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
                        var expected = {
                          TAG: "Ok",
                          _0: agdaMockTarget$1,
                          [Symbol.for("name")]: "Ok"
                        };
                        return Curry._3(Assert.deepEqual, actual, expected, undefined);
                      }));
                after(async function () {
                      var target = agdaMockTarget.contents;
                      if (target !== undefined) {
                        Test__Util$AgdaModeVscode.Target.Agda.destroy(target);
                        agdaMockTarget.contents = undefined;
                        return ;
                      }
                      
                    });
              }));
        describe("Command searching", (function () {
                it("should be able to find itself (`which` or `where`), although it's not a valid target", (async function () {
                        if (OS$AgdaModeVscode.onUnix) {
                          var _output = await Connection__Command$AgdaModeVscode.search("which", undefined);
                          if (_output.TAG === "Ok") {
                            return PervasivesU.failwith("should not be a valid target");
                          }
                          switch (_output._0.TAG) {
                            case "NotFound" :
                            case "SomethingWentWrong" :
                                return PervasivesU.failwith("expected to find `which`");
                            case "NotValidTarget" :
                                return ;
                            
                          }
                        } else {
                          var _output$1 = await Connection__Command$AgdaModeVscode.search("where", undefined);
                          if (_output$1.TAG === "Ok") {
                            return PervasivesU.failwith("should not be a valid target");
                          }
                          switch (_output$1._0.TAG) {
                            case "NotFound" :
                            case "SomethingWentWrong" :
                                return PervasivesU.failwith("expected to find `where`");
                            case "NotValidTarget" :
                                return ;
                            
                          }
                        }
                      }));
                it("should return an error when the command is not found", (async function () {
                        var _output = await Connection__Command$AgdaModeVscode.search("non-existent-command", undefined);
                        if (_output.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
        describe("findCommands", (function () {
                it("should return the connection when a command is found", (async function () {
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var error = await Connection$AgdaModeVscode.findCommands(commands);
                        if (error.TAG === "Ok") {
                          return ;
                        } else {
                          return PervasivesU.failwith("expected to find `agda` or `als`");
                        }
                      }));
                it("should return an error when the command is not found", (async function () {
                        var commands = ["non-existent-command"];
                        var match = await Connection$AgdaModeVscode.findCommands(commands);
                        if (match.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
        describe("make", (function () {
                it("Memento: [] / paths: [] / commands: ['agda', 'als']", (async function () {
                        var target = await Connection$AgdaModeVscode.findCommands(["agda"]);
                        var target$1;
                        target$1 = target.TAG === "Ok" ? target._0 : PervasivesU.failwith("expected to find `agda`");
                        await Config$AgdaModeVscode.Connection.setAgdaPaths([]);
                        var paths = Config$AgdaModeVscode.Connection.getAgdaPaths();
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var platform = await Connection__Download__Platform$AgdaModeVscode.determine();
                        var getDownloadPolicy = async function () {
                          return "Undecided";
                        };
                        var downloadLatestALS = async function (param) {
                          return {
                                  TAG: "Error",
                                  _0: "CannotFindCompatibleALSRelease",
                                  [Symbol.for("name")]: "Error"
                                };
                        };
                        var error = await Connection$AgdaModeVscode.make(memento, paths, commands, platform, getDownloadPolicy, downloadLatestALS);
                        if (error.TAG !== "Ok") {
                          var match = Connection__Error$AgdaModeVscode.toString(error._0);
                          PervasivesU.failwith("expected to find `agda` or `als`: " + match[0] + " - " + match[1]);
                        }
                        Curry._3(Assert.deepEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), [target$1].map(Connection__Target$AgdaModeVscode.toURI), undefined);
                        var pathIsNowInConfig = Util$AgdaModeVscode.$$Array.includes(Config$AgdaModeVscode.Connection.getAgdaPaths(), Connection__Target$AgdaModeVscode.toURI(target$1));
                        Assert.ok(pathIsNowInConfig);
                        var picked = await Connection__Target$AgdaModeVscode.getPicked(memento, Config$AgdaModeVscode.Connection.getAgdaPaths());
                        if (picked.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, picked._0, target$1, undefined);
                        } else {
                          return PervasivesU.failwith("expected to find the picked connection");
                        }
                      }));
                it("Memento: [] / paths: ['some/other/path'] / commands: ['agda', 'als']", (async function () {
                        var target = await Connection$AgdaModeVscode.findCommands(["agda"]);
                        var target$1;
                        target$1 = target.TAG === "Ok" ? target._0 : PervasivesU.failwith("expected to find `agda`");
                        await Config$AgdaModeVscode.Connection.setAgdaPaths(["some/other/path"].map(Connection__URI$AgdaModeVscode.parse));
                        var paths = Config$AgdaModeVscode.Connection.getAgdaPaths();
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var platform = await Connection__Download__Platform$AgdaModeVscode.determine();
                        var getDownloadPolicy = async function () {
                          return "Undecided";
                        };
                        var downloadLatestALS = async function (param) {
                          return {
                                  TAG: "Error",
                                  _0: "CannotFindCompatibleALSRelease",
                                  [Symbol.for("name")]: "Error"
                                };
                        };
                        var error = await Connection$AgdaModeVscode.make(memento, paths, commands, platform, getDownloadPolicy, downloadLatestALS);
                        if (error.TAG !== "Ok") {
                          var match = Connection__Error$AgdaModeVscode.toString(error._0);
                          PervasivesU.failwith("expected to find `agda` or `als`: " + match[0] + " - " + match[1]);
                        }
                        Curry._3(Assert.deepEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), Belt_Array.concatMany([
                                  paths,
                                  [Connection__Target$AgdaModeVscode.toURI(target$1)]
                                ]), undefined);
                        var pathIsNowInConfig = Util$AgdaModeVscode.$$Array.includes(Config$AgdaModeVscode.Connection.getAgdaPaths(), Connection__Target$AgdaModeVscode.toURI(target$1));
                        Assert.ok(pathIsNowInConfig);
                        var picked = await Connection__Target$AgdaModeVscode.getPicked(memento, Config$AgdaModeVscode.Connection.getAgdaPaths());
                        if (picked.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, picked._0, target$1, undefined);
                        } else {
                          return PervasivesU.failwith("expected to find the picked connection");
                        }
                      }));
                it("Memento: [] / paths: ['agda', 'others'] / commands: ['agda', 'als']", (async function () {
                        var target = await Connection$AgdaModeVscode.findCommands(["agda"]);
                        var target$1;
                        target$1 = target.TAG === "Ok" ? target._0 : PervasivesU.failwith("expected to find `agda`");
                        await Config$AgdaModeVscode.Connection.setAgdaPaths([
                              Connection__Target$AgdaModeVscode.toURI(target$1),
                              Connection__URI$AgdaModeVscode.parse("some/other/path")
                            ]);
                        var paths = Config$AgdaModeVscode.Connection.getAgdaPaths();
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var platform = await Connection__Download__Platform$AgdaModeVscode.determine();
                        var getDownloadPolicy = async function () {
                          return "Undecided";
                        };
                        var downloadLatestALS = async function (param) {
                          return {
                                  TAG: "Error",
                                  _0: "CannotFindCompatibleALSRelease",
                                  [Symbol.for("name")]: "Error"
                                };
                        };
                        var error = await Connection$AgdaModeVscode.make(memento, paths, commands, platform, getDownloadPolicy, downloadLatestALS);
                        if (error.TAG !== "Ok") {
                          var match = Connection__Error$AgdaModeVscode.toString(error._0);
                          PervasivesU.failwith("expected to find `agda` or `als`: " + match[0] + " - " + match[1]);
                        }
                        Curry._3(Assert.deepEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), paths, undefined);
                        var picked = await Connection__Target$AgdaModeVscode.getPicked(memento, Config$AgdaModeVscode.Connection.getAgdaPaths());
                        if (picked.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, picked._0, target$1, undefined);
                        } else {
                          return PervasivesU.failwith("expected to find the picked connection");
                        }
                      }));
                describe("No local installation", (function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [Connection__URI$AgdaModeVscode.parse("some/other/path")];
                        var commands = ["non-existent-command"];
                        var expectedAttempts_targets = [{
                            uri: Connection__URI$AgdaModeVscode.parse("some/other/path"),
                            error: {
                              TAG: "ValidationError",
                              _0: "some/other/path",
                              _1: {
                                TAG: "NotFound",
                                _0: "some/other/path",
                                [Symbol.for("name")]: "NotFound"
                              },
                              [Symbol.for("name")]: "ValidationError"
                            }
                          }];
                        var expectedAttempts_commands = [{
                            TAG: "NotFound",
                            _0: "non-existent-command",
                            [Symbol.for("name")]: "NotFound"
                          }];
                        var expectedAttempts = {
                          targets: expectedAttempts_targets,
                          commands: expectedAttempts_commands
                        };
                        it("should throw the `PlatformNotSupported` error when the platform is not supported", (async function () {
                                var platform = {
                                  os: "non-existent-os",
                                  dist: "non-existent-dist",
                                  codename: "non-existent-codename",
                                  release: "non-existent-release"
                                };
                                await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                                var getDownloadPolicyCount = {
                                  contents: 0
                                };
                                var getDownloadPolicy = async function () {
                                  getDownloadPolicyCount.contents = getDownloadPolicyCount.contents + 1 | 0;
                                  return "Undecided";
                                };
                                var downloadLatestALS = async function (param) {
                                  return {
                                          TAG: "Error",
                                          _0: "CannotFindCompatibleALSRelease",
                                          [Symbol.for("name")]: "Error"
                                        };
                                };
                                var result = await Connection$AgdaModeVscode.make(memento, paths, commands, {
                                      TAG: "Error",
                                      _0: platform,
                                      [Symbol.for("name")]: "Error"
                                    }, getDownloadPolicy, downloadLatestALS);
                                Curry._3(Assert.deepEqual, result, {
                                      TAG: "Error",
                                      _0: {
                                        TAG: "Aggregated",
                                        _0: {
                                          TAG: "PlatformNotSupported",
                                          _0: expectedAttempts,
                                          _1: platform,
                                          [Symbol.for("name")]: "PlatformNotSupported"
                                        },
                                        [Symbol.for("name")]: "Aggregated"
                                      },
                                      [Symbol.for("name")]: "Error"
                                    }, undefined);
                                return Curry._3(Assert.deepEqual, getDownloadPolicyCount.contents, 0, undefined);
                              }));
                        it("should throw the `NoDownloadALS` error when the inital download policy is `No`", (async function () {
                                await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
                                var getDownloadPolicyCount = {
                                  contents: 0
                                };
                                var getDownloadPolicy = async function () {
                                  getDownloadPolicyCount.contents = getDownloadPolicyCount.contents + 1 | 0;
                                  return "No";
                                };
                                var downloadLatestALS = async function (param) {
                                  return {
                                          TAG: "Error",
                                          _0: "CannotFindCompatibleALSRelease",
                                          [Symbol.for("name")]: "Error"
                                        };
                                };
                                var result = await Connection$AgdaModeVscode.make(memento, paths, commands, {
                                      TAG: "Ok",
                                      _0: "Windows",
                                      [Symbol.for("name")]: "Ok"
                                    }, getDownloadPolicy, downloadLatestALS);
                                Curry._3(Assert.deepEqual, result, {
                                      TAG: "Error",
                                      _0: {
                                        TAG: "Aggregated",
                                        _0: {
                                          TAG: "NoDownloadALS",
                                          _0: expectedAttempts,
                                          [Symbol.for("name")]: "NoDownloadALS"
                                        },
                                        [Symbol.for("name")]: "Aggregated"
                                      },
                                      [Symbol.for("name")]: "Error"
                                    }, undefined);
                                var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                                Curry._3(Assert.deepEqual, policy, "No", undefined);
                                return Curry._3(Assert.deepEqual, getDownloadPolicyCount.contents, 0, undefined);
                              }));
                        it("should throw the `NoDownloadALS` error when the user clicked `cancel` on the download dialog", (async function () {
                                await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                                var getDownloadPolicyCount = {
                                  contents: 0
                                };
                                var getDownloadPolicy = async function () {
                                  getDownloadPolicyCount.contents = getDownloadPolicyCount.contents + 1 | 0;
                                  return "Undecided";
                                };
                                var downloadLatestALS = async function (param) {
                                  return {
                                          TAG: "Error",
                                          _0: "CannotFindCompatibleALSRelease",
                                          [Symbol.for("name")]: "Error"
                                        };
                                };
                                var result = await Connection$AgdaModeVscode.make(memento, paths, commands, {
                                      TAG: "Ok",
                                      _0: "Windows",
                                      [Symbol.for("name")]: "Ok"
                                    }, getDownloadPolicy, downloadLatestALS);
                                Curry._3(Assert.deepEqual, result, {
                                      TAG: "Error",
                                      _0: {
                                        TAG: "Aggregated",
                                        _0: {
                                          TAG: "NoDownloadALS",
                                          _0: expectedAttempts,
                                          [Symbol.for("name")]: "NoDownloadALS"
                                        },
                                        [Symbol.for("name")]: "Aggregated"
                                      },
                                      [Symbol.for("name")]: "Error"
                                    }, undefined);
                                var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                                Curry._3(Assert.deepEqual, policy, "No", undefined);
                                return Curry._3(Assert.deepEqual, getDownloadPolicyCount.contents, 1, undefined);
                              }));
                        it("should throw the `DownloadALS` error when the download policy is `Yes` but the download fails", (async function () {
                                await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                                var getDownloadPolicy = async function () {
                                  return "Yes";
                                };
                                var downloadLatestALS = async function (param) {
                                  return {
                                          TAG: "Error",
                                          _0: "CannotFindCompatibleALSRelease",
                                          [Symbol.for("name")]: "Error"
                                        };
                                };
                                var result = await Connection$AgdaModeVscode.make(memento, paths, commands, {
                                      TAG: "Ok",
                                      _0: "Windows",
                                      [Symbol.for("name")]: "Ok"
                                    }, getDownloadPolicy, downloadLatestALS);
                                Curry._3(Assert.deepEqual, result, {
                                      TAG: "Error",
                                      _0: {
                                        TAG: "Aggregated",
                                        _0: {
                                          TAG: "DownloadALS",
                                          _0: expectedAttempts,
                                          _1: "CannotFindCompatibleALSRelease",
                                          [Symbol.for("name")]: "DownloadALS"
                                        },
                                        [Symbol.for("name")]: "Aggregated"
                                      },
                                      [Symbol.for("name")]: "Error"
                                    }, undefined);
                                var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                                return Curry._3(Assert.deepEqual, policy, "Yes", undefined);
                              }));
                      }));
              }));
      }));

/*  Not a pure module */
