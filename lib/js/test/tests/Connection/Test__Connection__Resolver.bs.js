// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Assert = require("assert");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Nodefs = require("node:fs");
var Nodeos = require("node:os");
var Nodenet = require("node:net");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var State__Type$AgdaModeVscode = require("../../../src/State/State__Type.bs.js");
var Connection__Resolver$AgdaModeVscode = require("../../../src/Connection/Connection__Resolver.bs.js");
var Connection__Resolver__TCP$AgdaModeVscode = require("../../../src/Connection/Resolver/Connection__Resolver__TCP.bs.js");
var Connection__Resolver__GitHub$AgdaModeVscode = require("../../../src/Connection/Resolver/Connection__Resolver__GitHub.bs.js");
var Connection__Resolver__Command$AgdaModeVscode = require("../../../src/Connection/Resolver/Connection__Resolver__Command.bs.js");

describe("Path Searching", (function () {
        this.timeout(10000);
        describe("`Source.search` with `FromFile`", (function () {
                before(async function () {
                      var file = await Nodefs.promises.open("temp", "w");
                      return await file.writeFile(Buffer.from("test"));
                    });
                it("for file that exists", (async function () {
                        var err = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromFile",
                              _0: "temp",
                              [Symbol.for("name")]: "FromFile"
                            }, 1000);
                        if (err.TAG !== "Ok") {
                          return Js_exn.raiseError(Connection__Resolver$AgdaModeVscode.$$Error.toString(err._0));
                        }
                        var match = err._0;
                        if (match.TAG !== "ViaPipe") {
                          return Js_exn.raiseError("Expected ViaCommand");
                        }
                        Curry._3(Assert.deepEqual, match._0, "temp", undefined);
                        Curry._3(Assert.deepEqual, match._1, [], undefined);
                        Curry._3(Assert.deepEqual, match._2, undefined, undefined);
                        return Curry._3(Assert.deepEqual, match._3, {
                                    TAG: "FromFile",
                                    _0: "temp",
                                    [Symbol.for("name")]: "FromFile"
                                  }, undefined);
                      }));
                it("for file that doesn't exist", (async function () {
                        var error = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromFile",
                              _0: "temp-non-existing",
                              [Symbol.for("name")]: "FromFile"
                            }, 1000);
                        if (error.TAG === "Ok") {
                          return Js_exn.raiseError("Expected Error");
                        } else {
                          return Curry._3(Assert.deepEqual, error._0, {
                                      TAG: "File",
                                      _0: "temp-non-existing",
                                      [Symbol.for("name")]: "File"
                                    }, undefined);
                        }
                      }));
                after(async function () {
                      Nodefs.unlinkSync("temp");
                    });
              }));
        describe("`Source.search` with `FromCommand`", (function () {
                it("for command that exists", (async function () {
                        var err = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromCommand",
                              _0: "which",
                              [Symbol.for("name")]: "FromCommand"
                            }, undefined);
                        if (err.TAG !== "Ok") {
                          return Js_exn.raiseError(Connection__Resolver$AgdaModeVscode.$$Error.toString(err._0));
                        }
                        var match = err._0;
                        if (match.TAG !== "ViaPipe") {
                          return Js_exn.raiseError("Expected ViaCommand");
                        }
                        var err$1 = await Connection__Resolver__Command$AgdaModeVscode.search("which", undefined);
                        var path;
                        path = err$1.TAG === "Ok" ? err$1._0 : Js_exn.raiseError(Connection__Resolver__Command$AgdaModeVscode.$$Error.toString(err$1._0));
                        Curry._3(Assert.deepEqual, match._0, path, undefined);
                        Curry._3(Assert.deepEqual, match._1, [], undefined);
                        Curry._3(Assert.deepEqual, match._2, undefined, undefined);
                        return Curry._3(Assert.deepEqual, match._3, {
                                    TAG: "FromCommand",
                                    _0: "which",
                                    [Symbol.for("name")]: "FromCommand"
                                  }, undefined);
                      }));
                it("for command that doesn't exist", (async function () {
                        var error = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromCommand",
                              _0: "temp-non-existing",
                              [Symbol.for("name")]: "FromCommand"
                            }, undefined);
                        if (error.TAG === "Ok") {
                          return Js_exn.raiseError("Expected Error");
                        } else {
                          return Curry._3(Assert.deepEqual, error._0, {
                                      TAG: "Command",
                                      _0: "temp-non-existing",
                                      _1: "NotFound",
                                      [Symbol.for("name")]: "Command"
                                    }, undefined);
                        }
                      }));
              }));
        describe("`Source.search` with `FromTCP`", (function () {
                var serverRef = {
                  contents: undefined
                };
                before(async function () {
                      var server = new Nodenet.Server();
                      server.listen(23456, "localhost", (function () {
                              
                            }));
                      serverRef.contents = Caml_option.some(server);
                    });
                it("for TCP server that exists", (async function () {
                        var err = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromTCP",
                              _0: 23456,
                              _1: "localhost",
                              [Symbol.for("name")]: "FromTCP"
                            }, 5000);
                        if (err.TAG !== "Ok") {
                          return Js_exn.raiseError(Connection__Resolver$AgdaModeVscode.$$Error.toString(err._0));
                        }
                        var match = err._0;
                        if (match.TAG === "ViaPipe") {
                          return Js_exn.raiseError("Expected ViaTCP");
                        }
                        Curry._3(Assert.deepEqual, match._0, 23456, undefined);
                        Curry._3(Assert.deepEqual, match._1, "localhost", undefined);
                        return Curry._3(Assert.deepEqual, match._2, {
                                    TAG: "FromTCP",
                                    _0: 23456,
                                    _1: "localhost",
                                    [Symbol.for("name")]: "FromTCP"
                                  }, undefined);
                      }));
                it("for local TCP server that doesn't exist", (async function () {
                        var match = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromTCP",
                              _0: 23457,
                              _1: "localhost",
                              [Symbol.for("name")]: "FromTCP"
                            }, 5000);
                        if (match.TAG === "Ok") {
                          return Js_exn.raiseError("Expecting Error");
                        }
                        var match$1 = match._0;
                        if (match$1.TAG === "TCP") {
                          Curry._3(Assert.deepEqual, match$1._0, 23457, undefined);
                          Curry._3(Assert.deepEqual, match$1._1, "localhost", undefined);
                          return Curry._3(Assert.deepEqual, Connection__Resolver__TCP$AgdaModeVscode.$$Error.toString(match$1._2), "AggregateError", undefined);
                        }
                        throw {
                              RE_EXN_ID: "Failure",
                              _1: "Expecting TCP-related error",
                              Error: new Error()
                            };
                      }));
                it("for remote TCP server that doesn't exist", (async function () {
                        var match = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromTCP",
                              _0: 23457,
                              _1: "remotehost",
                              [Symbol.for("name")]: "FromTCP"
                            }, 5000);
                        if (match.TAG === "Ok") {
                          return Js_exn.raiseError("Expecting Error");
                        }
                        var match$1 = match._0;
                        if (match$1.TAG === "TCP") {
                          var error = match$1._2;
                          Curry._3(Assert.deepEqual, match$1._0, 23457, undefined);
                          Curry._3(Assert.deepEqual, match$1._1, "remotehost", undefined);
                          var result = await Connection__Resolver__GitHub$AgdaModeVscode.Platform.determine();
                          var match$2 = result.os;
                          switch (match$2) {
                            case "linux" :
                                if (result.dist === "Ubuntu") {
                                  return Curry._3(Assert.deepEqual, Connection__Resolver__TCP$AgdaModeVscode.$$Error.toString(error), "Error: getaddrinfo EAI_AGAIN remotehost", undefined);
                                } else {
                                  return ;
                                }
                            case "darwin" :
                            case "win32" :
                                return Curry._3(Assert.deepEqual, Connection__Resolver__TCP$AgdaModeVscode.$$Error.toString(error), "Error: getaddrinfo ENOTFOUND remotehost", undefined);
                            default:
                              return ;
                          }
                        } else {
                          throw {
                                RE_EXN_ID: "Failure",
                                _1: "Expecting TCP-related error",
                                Error: new Error()
                              };
                        }
                      }));
                after(async function () {
                      var server = serverRef.contents;
                      if (server !== undefined) {
                        Caml_option.valFromOption(server).close(function (param) {
                              
                            });
                        serverRef.contents = undefined;
                        return ;
                      } else {
                        return Js_exn.raiseError("Server not found");
                      }
                    });
              }));
        describe.skip("`Source.search` with `FromGitHub`", (function () {
                var downloadDirRef = {
                  contents: undefined
                };
                var afterDownload = async function (isCached, param) {
                  var path = param[0];
                  var assetPath = Nodepath.join(path, "data");
                  var env = Js_dict.fromArray([[
                          "Agda_datadir",
                          assetPath
                        ]]);
                  var options_env = env;
                  var options = {
                    env: options_env
                  };
                  var execPath = Nodepath.join(path, "als");
                  var shouldChmod = !isCached && Nodeos.platform() !== "win32";
                  if (shouldChmod) {
                    await Connection__Resolver__GitHub$AgdaModeVscode.chmodExecutable(execPath);
                  }
                  downloadDirRef.contents = path;
                  return {
                          TAG: "Ok",
                          _0: [
                            execPath,
                            [],
                            options,
                            param[1]
                          ],
                          [Symbol.for("name")]: "Ok"
                        };
                };
                var repo_memento = State__Type$AgdaModeVscode.Memento.make(undefined);
                var repo = {
                  username: "agda",
                  repository: "agda-language-server",
                  userAgent: "agda/agda-mode-vscode",
                  memento: repo_memento,
                  globalStoragePath: "./",
                  cacheInvalidateExpirationSecs: 86400
                };
                var callbacks_chooseFromReleases = function (releases) {
                  var release = Connection__Resolver__GitHub$AgdaModeVscode.Release.chooseByTagName(releases, "v0.2.6.4.0.3");
                  if (release === undefined) {
                    return ;
                  }
                  var asset = Connection__Resolver__GitHub$AgdaModeVscode.Asset.chooseByName(release.assets, "als-windows.zip");
                  if (asset !== undefined) {
                    return {
                            release: release,
                            asset: asset,
                            saveAsFileName: release.tag_name + "-als-windows.zip"
                          };
                  }
                  
                };
                var callbacks_onDownload = function (param) {
                  
                };
                var callbacks_log = function (x) {
                  console.log(x);
                };
                var callbacks = {
                  chooseFromReleases: callbacks_chooseFromReleases,
                  onDownload: callbacks_onDownload,
                  afterDownload: afterDownload,
                  log: callbacks_log
                };
                it("download v0.2.6.4.0.3 from GitHub the first time", (async function () {
                        this.timeout(600000);
                        var err = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromGitHub",
                              _0: repo,
                              _1: callbacks,
                              [Symbol.for("name")]: "FromGitHub"
                            }, undefined);
                        if (err.TAG !== "Ok") {
                          return Js_exn.raiseError(Connection__Resolver$AgdaModeVscode.$$Error.toString(err._0));
                        }
                        var match = err._0;
                        if (match.TAG !== "ViaPipe") {
                          return Js_exn.raiseError("Expected ViaPipe");
                        }
                        var source = match._3;
                        var path = downloadDirRef.contents;
                        var downloadDir = path !== undefined ? path : Js_exn.raiseError("Expected download path");
                        Curry._3(Assert.deepEqual, match._0, Nodepath.join(downloadDir, "als"), undefined);
                        Curry._3(Assert.deepEqual, match._1, [], undefined);
                        var expectedOptions = {
                          env: Object.fromEntries([[
                                  "Agda_datadir",
                                  Nodepath.join(downloadDir, "data")
                                ]])
                        };
                        Curry._3(Assert.deepEqual, match._2, expectedOptions, undefined);
                        if (source.TAG !== "FromGitHub") {
                          return Js_exn.raiseError("Expected FromGitHub");
                        }
                        var repo$1 = source._0;
                        Curry._3(Assert.deepEqual, repo$1.username, "agda", undefined);
                        Curry._3(Assert.deepEqual, repo$1.repository, "agda-language-server", undefined);
                        Curry._3(Assert.deepEqual, repo$1.userAgent, "agda/agda-mode-vscode", undefined);
                        Curry._3(Assert.deepEqual, repo$1.globalStoragePath, "./", undefined);
                        return Curry._3(Assert.deepEqual, source._1.tag_name, "v0.2.6.4.0.3", undefined);
                      }));
                it("download v0.2.6.4.0.3 from GitHub the second time", (async function () {
                        this.timeout(1000);
                        var err = await Connection__Resolver$AgdaModeVscode.search({
                              TAG: "FromGitHub",
                              _0: repo,
                              _1: callbacks,
                              [Symbol.for("name")]: "FromGitHub"
                            }, 1000);
                        if (err.TAG !== "Ok") {
                          return Js_exn.raiseError(Connection__Resolver$AgdaModeVscode.$$Error.toString(err._0));
                        }
                        var match = err._0;
                        if (match.TAG !== "ViaPipe") {
                          return Js_exn.raiseError("Expected ViaPipe");
                        }
                        var source = match._3;
                        var path = downloadDirRef.contents;
                        var downloadDir = path !== undefined ? path : Js_exn.raiseError("Expected download path");
                        Curry._3(Assert.deepEqual, match._0, Nodepath.join(downloadDir, "als"), undefined);
                        Curry._3(Assert.deepEqual, match._1, [], undefined);
                        var expectedOptions = {
                          env: Object.fromEntries([[
                                  "Agda_datadir",
                                  Nodepath.join(downloadDir, "data")
                                ]])
                        };
                        Curry._3(Assert.deepEqual, match._2, expectedOptions, undefined);
                        if (source.TAG !== "FromGitHub") {
                          return Js_exn.raiseError("Expected FromGitHub");
                        }
                        var repo$1 = source._0;
                        Curry._3(Assert.deepEqual, repo$1.username, "agda", undefined);
                        Curry._3(Assert.deepEqual, repo$1.repository, "agda-language-server", undefined);
                        Curry._3(Assert.deepEqual, repo$1.userAgent, "agda/agda-mode-vscode", undefined);
                        Curry._3(Assert.deepEqual, repo$1.globalStoragePath, "./", undefined);
                        return Curry._3(Assert.deepEqual, source._1.tag_name, "v0.2.6.4.0.3", undefined);
                      }));
                after(async function () {
                      try {
                        Nodefs.unlinkSync("releases-cache.json");
                        Nodefs.unlinkSync("in-flight.download");
                      }
                      catch (exn){
                        
                      }
                      var path = downloadDirRef.contents;
                      if (path !== undefined) {
                        return await Nodefs.promises.rm(path, {
                                    force: true,
                                    recursive: true
                                  });
                      }
                      
                    });
              }));
      }));

var Resolver;

exports.Resolver = Resolver;
/*  Not a pure module */
