// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Core__Dict = require("@rescript/core/lib/js/src/Core__Dict.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Util$AgdaModeVscode = require("../../../Util/Util.bs.js");

function partite(xs, tagEntry) {
  var keys = Core__Array.filterMap(xs.map(function (x, i) {
            return [
                    i,
                    x
                  ];
          }), (function (param) {
          var i = param[0];
          return Core__Option.map(tagEntry([
                          param[1],
                          i
                        ]), (function (key) {
                        return [
                                key,
                                i
                              ];
                      }));
        }));
  var intervals = keys.map(function (param, n) {
        var index = param[1];
        var key = param[0];
        var match = keys[n + 1 | 0];
        if (match !== undefined) {
          return [
                  key,
                  index,
                  match[1]
                ];
        } else {
          return [
                  key,
                  index,
                  xs.length
                ];
        }
      });
  return Object.fromEntries(intervals.map(function (param) {
                  return [
                          param[0],
                          xs.slice(param[1], param[2]).filter(function (x) {
                                return x !== "";
                              })
                        ];
                }));
}

function split(dict, key, splitter) {
  var value = dict[key];
  if (value !== undefined) {
    Object.entries(splitter(value)).forEach(function (param) {
          dict[param[0]] = param[1];
        });
    Core__Dict.$$delete(dict, key);
    return dict;
  } else {
    return dict;
  }
}

function update(dict, key, f) {
  var value = dict[key];
  if (value !== undefined) {
    dict[key] = f(Caml_option.valFromOption(value));
    return dict;
  } else {
    return dict;
  }
}

var Dictionary = {
  partite: partite,
  split: split,
  update: update
};

function partite$1(xs, p) {
  var indices = xs.map(function (x, i) {
            return [
                    i,
                    x
                  ];
          }).filter(function (param) {
          return p(param[1]);
        }).map(function (prim) {
        return prim[0];
      });
  var n = indices[0];
  var indicesWF = n !== undefined ? (
      n === 0 ? indices : indices.concat([0])
    ) : (
      indices.length === 0 ? [0] : indices
    );
  var intervals = indicesWF.map(function (index, n) {
        var next = indicesWF[n + 1 | 0];
        if (next !== undefined) {
          return [
                  index,
                  next
                ];
        } else {
          return [
                  index,
                  xs.length
                ];
        }
      });
  return intervals.map(function (param) {
              return xs.slice(param[0], param[1]);
            });
}

function mergeWithNext(xs, p) {
  return Core__Array.reduce(xs, [], (function (acc, x) {
                var last = acc[acc.length - 1 | 0];
                if (last !== undefined) {
                  if (p(last)) {
                    acc[acc.length - 1 | 0] = x.concat(last);
                    return acc;
                  } else {
                    return [x].concat(acc);
                  }
                } else {
                  return [x];
                }
              }));
}

var Array_ = {
  partite: partite$1,
  mergeWithNext: mergeWithNext
};

function aggregateLines(lines) {
  var newlineRegEx = function (line) {
    return /^\S/.test(line);
  };
  var newLineIndices = lines.map(function (line, index) {
            return [
                    index,
                    newlineRegEx(line)
                  ];
          }).filter(function (param) {
          return param[1];
        }).map(function (prim) {
        return prim[0];
      });
  return newLineIndices.map(function (index, i) {
                var n = newLineIndices[i + 1 | 0];
                if (n !== undefined) {
                  return [
                          index,
                          n
                        ];
                } else {
                  return [
                          index,
                          lines.length + 1 | 0
                        ];
                }
              }).map(function (param) {
              return Util$AgdaModeVscode.$$String.unlines(lines.slice(param[0], param[1]));
            });
}

function captures(regex, handler, raw) {
  return Core__Option.flatMap(Caml_option.nullable_to_opt(regex.exec(raw)), handler);
}

function choice(res, raw) {
  return Core__Array.reduce(res, undefined, (function (result, parse) {
                if (result !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(result));
                } else {
                  return parse(raw);
                }
              }));
}

function at(captured, i, parser) {
  if (i >= captured.length) {
    return ;
  } else {
    return Core__Option.flatMap(Core__Option.flatMap(captured[i], (function (x) {
                      return x;
                    })), parser);
  }
}

exports.Dictionary = Dictionary;
exports.Array_ = Array_;
exports.aggregateLines = aggregateLines;
exports.captures = captures;
exports.choice = choice;
exports.at = at;
/* Util-AgdaModeVscode Not a pure module */
