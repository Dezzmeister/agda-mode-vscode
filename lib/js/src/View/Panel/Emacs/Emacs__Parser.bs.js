// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Util$AgdaModeVscode = require("../../../Util/Util.bs.js");

function partite(xs, tagEntry) {
  var keys = Belt_Array.keepMap(Belt_Array.mapWithIndex(xs, (function (i, x) {
              return [
                      i,
                      x
                    ];
            })), (function (param) {
          var i = param[0];
          return Belt_Option.map(tagEntry([
                          param[1],
                          i
                        ]), (function (key) {
                        return [
                                key,
                                i
                              ];
                      }));
        }));
  var intervals = Belt_Array.mapWithIndex(keys, (function (n, param) {
          var index = param[1];
          var key = param[0];
          var match = Belt_Array.get(keys, n + 1 | 0);
          if (match !== undefined) {
            return [
                    key,
                    index,
                    match[1]
                  ];
          } else {
            return [
                    key,
                    index,
                    xs.length
                  ];
          }
        }));
  return Js_dict.fromArray(Belt_Array.map(intervals, (function (param) {
                    return [
                            param[0],
                            Belt_Array.keep(Js_array.slice(param[1], param[2], xs), (function (x) {
                                    return x !== "";
                                  }))
                          ];
                  })));
}

function split(dict, key, splitter) {
  var value = Js_dict.get(dict, key);
  if (value !== undefined) {
    Belt_Array.forEach(Js_dict.entries(splitter(value)), (function (param) {
            dict[param[0]] = param[1];
          }));
    Util$AgdaModeVscode.Dict.$$delete(dict, key);
    return dict;
  } else {
    return dict;
  }
}

function update(dict, key, f) {
  var value = Js_dict.get(dict, key);
  if (value !== undefined) {
    dict[key] = f(Caml_option.valFromOption(value));
    return dict;
  } else {
    return dict;
  }
}

var Dict = {
  partite: partite,
  split: split,
  update: update
};

function partite$1(xs, p) {
  var indices = Belt_Array.map(Belt_Array.keep(Belt_Array.mapWithIndex(xs, (function (i, x) {
                  return [
                          i,
                          x
                        ];
                })), (function (param) {
              return p(param[1]);
            })), (function (prim) {
          return prim[0];
        }));
  var n = Belt_Array.get(indices, 0);
  var indicesWF = n !== undefined ? (
      n === 0 ? indices : Belt_Array.concat(indices, [0])
    ) : (
      indices.length === 0 ? [0] : indices
    );
  var intervals = Belt_Array.mapWithIndex(indicesWF, (function (n, index) {
          var next = Belt_Array.get(indicesWF, n + 1 | 0);
          if (next !== undefined) {
            return [
                    index,
                    next
                  ];
          } else {
            return [
                    index,
                    xs.length
                  ];
          }
        }));
  return Belt_Array.map(intervals, (function (param) {
                return Js_array.slice(param[0], param[1], xs);
              }));
}

function mergeWithNext(xs, p) {
  return Belt_Array.reduce(xs, [], (function (acc, x) {
                var last = Belt_Array.get(acc, acc.length - 1 | 0);
                if (last !== undefined) {
                  if (p(last)) {
                    Belt_Array.set(acc, acc.length - 1 | 0, Belt_Array.concat(x, last));
                    return acc;
                  } else {
                    return Belt_Array.concat([x], acc);
                  }
                } else {
                  return [x];
                }
              }));
}

var Array_ = {
  partite: partite$1,
  mergeWithNext: mergeWithNext
};

function aggregateLines(lines) {
  var newlineRegEx = function (line) {
    return /^\S/.test(line);
  };
  var newLineIndices = Belt_Array.map(Belt_Array.keep(Belt_Array.mapWithIndex(lines, (function (index, line) {
                  return [
                          index,
                          newlineRegEx(line)
                        ];
                })), (function (param) {
              return param[1];
            })), (function (prim) {
          return prim[0];
        }));
  return Belt_Array.map(Belt_Array.mapWithIndex(newLineIndices, (function (i, index) {
                    var n = Belt_Array.get(newLineIndices, i + 1 | 0);
                    if (n !== undefined) {
                      return [
                              index,
                              n
                            ];
                    } else {
                      return [
                              index,
                              lines.length + 1 | 0
                            ];
                    }
                  })), (function (param) {
                return Util$AgdaModeVscode.$$String.unlines(lines.slice(param[0], param[1]));
              }));
}

function captures(regex, handler, raw) {
  return Belt_Option.flatMap(Belt_Option.map(Caml_option.null_to_opt(regex.exec(raw)), (function (result) {
                    return Belt_Array.map(result, (function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }));
                  })), handler);
}

function choice(res, raw) {
  return Js_array.reduce((function (result, parse) {
                if (result !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(result));
                } else {
                  return parse(raw);
                }
              }), undefined, res);
}

function at(captured, i, parser) {
  if (i >= captured.length) {
    return ;
  } else {
    return Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, i), (function (x) {
                      return x;
                    })), parser);
  }
}

exports.Dict = Dict;
exports.Array_ = Array_;
exports.aggregateLines = aggregateLines;
exports.captures = captures;
exports.choice = choice;
exports.at = at;
/* Util-AgdaModeVscode Not a pure module */
