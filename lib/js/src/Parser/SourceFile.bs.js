// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");

function parse(filepath) {
  if (/\.lagda\.rst$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateRST";
  } else if (/\.lagda\.md$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateMarkdown";
  } else if (/\.lagda\.tex$|\.lagda$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateTeX";
  } else if (/\.lagda\.org$/i.test(Parser$AgdaModeVscode.filepath(filepath))) {
    return "LiterateOrg";
  } else {
    return "Agda";
  }
}

var FileType = {
  parse: parse
};

function isHole(token) {
  var match = token.kind;
  switch (match) {
    case "GoalBracket" :
    case "GoalQM" :
        return true;
    default:
      return false;
  }
}

var Token = {
  isHole: isHole
};

function make(raw) {
  return [{
            content: raw,
            range: [
              0,
              raw.length
            ],
            kind: "AgdaRaw"
          }];
}

function lex(regex, source, target, tokens) {
  var f = function (token) {
    if (token.kind !== source) {
      return [token];
    }
    var cursor = {
      contents: token.range[0]
    };
    return Belt_Array.map(Belt_Array.keepMap((function (__x) {
                        return Js_string.splitByRe(regex, __x);
                      })(token.content), (function (x) {
                      return x;
                    })), (function (content) {
                  var kind = regex.test(content) ? target : source;
                  var cursorOld = cursor.contents;
                  cursor.contents = cursor.contents + content.length | 0;
                  return {
                          content: content,
                          range: [
                            cursorOld,
                            cursor.contents
                          ],
                          kind: kind
                        };
                }));
  };
  return Belt_Array.concatMany(Belt_Array.map(tokens, f));
}

function map(f, self) {
  var delta = {
    contents: 0
  };
  return Belt_Array.map(self, (function (token) {
                var match = f(token);
                var content = match.content;
                var match$1 = token.range;
                var lengthDiff = content.length - token.content.length | 0;
                var result_range = [
                  match$1[0] + delta.contents | 0,
                  (match$1[1] + delta.contents | 0) + lengthDiff | 0
                ];
                var result_kind = match.kind;
                var result = {
                  content: content,
                  range: result_range,
                  kind: result_kind
                };
                delta.contents = delta.contents + lengthDiff | 0;
                return result;
              }));
}

function mapOnly(kind, f, self) {
  return map((function (token) {
                if (token.kind === kind) {
                  return f(token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = {
  make: make,
  lex: lex,
  map: map,
  mapOnly: mapOnly
};

var texBegin = /\\begin\{code\}.*/;

var texEnd = /\\end\{code\}.*/;

var markdown = /\`\`\`(agda)?/;

var rstBegin = /\:\:/;

var rstEnd = /^[^\s]/;

var orgBegin = /\#\+begin\_src agda2/i;

var orgEnd = /\#\+end\_src/i;

var comment = /((?<=^|[\s\"\_\;\.\(\)\{\}\@])--[^\r\n]*(?:\r|\n|$))|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/;

var goalBracket = /(\{\!(?:(?!\!\})(?:.|\s))*\!\})/;

var goalQuestionMarkRaw = /([\s\(\{\_\;\.\\\"@]|^)(\?)([\s\)\}\_\;\.\\\"@]|$)/gm;

var goalQuestionMark = /(\?)/;

var goalBracketContent = /\{\!((?:(?!\!\})(?:.|\s))*)\!\}/;

var Regex = {
  texBegin: texBegin,
  texEnd: texEnd,
  markdown: markdown,
  rstBegin: rstBegin,
  rstEnd: rstEnd,
  orgBegin: orgBegin,
  orgEnd: orgEnd,
  comment: comment,
  goalBracket: goalBracket,
  goalQuestionMarkRaw: goalQuestionMarkRaw,
  goalQuestionMark: goalQuestionMark,
  goalBracketContent: goalBracketContent
};

function toTokens(raw) {
  var cursor = {
    contents: 0
  };
  return Belt_Option.mapWithDefault(Js_string.match_(/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g, raw), [], (function (lines) {
                return Belt_Array.map(Belt_Array.keep(Belt_Array.map(lines, (function (x) {
                                      if (x !== undefined) {
                                        return x;
                                      } else {
                                        return "";
                                      }
                                    })), (function (s) {
                                  return s !== "";
                                })), (function (line) {
                              var cursorOld = cursor.contents;
                              cursor.contents = cursor.contents + line.length | 0;
                              return {
                                      content: Js_string.substring(cursorOld, cursor.contents, raw),
                                      range: [
                                        cursorOld,
                                        cursor.contents
                                      ],
                                      kind: "Literate"
                                    };
                            }));
              }));
}

function markWithRules(begin_, end_, raw) {
  var previous = {
    contents: false
  };
  var current = {
    contents: false
  };
  return Belt_Array.map(toTokens(raw), (function (token) {
                var content = token.content;
                previous.contents = current.contents;
                if (begin_.test(content) && !current.contents) {
                  current.contents = true;
                } else if (end_.test(content) && current.contents) {
                  current.contents = false;
                }
                var insideAgda = previous.contents && current.contents;
                var kind = insideAgda ? "AgdaRaw" : "Literate";
                return {
                        content: content,
                        range: token.range,
                        kind: kind
                      };
              }));
}

function markMarkdown(extra) {
  return markWithRules(markdown, markdown, extra);
}

function markTex(extra) {
  return markWithRules(texBegin, texEnd, extra);
}

function markRST(extra) {
  return markWithRules(rstBegin, rstEnd, extra);
}

function markOrg(extra) {
  return markWithRules(orgBegin, orgEnd, extra);
}

var Literate = {
  toTokens: toTokens,
  markWithRules: markWithRules,
  markMarkdown: markMarkdown,
  markTex: markTex,
  markRST: markRST,
  markOrg: markOrg
};

function toString(param) {
  var originalInterval = param.originalInterval;
  var modifiedInterval = param.modifiedInterval;
  return "Hole [" + (String(param.index) + ("] (" + (String(originalInterval[0]) + (", " + (String(originalInterval[1]) + (") => (" + (String(modifiedInterval[0]) + (", " + (String(modifiedInterval[1]) + (") \"" + (param.content + "\"")))))))))));
}

var Diff = {
  toString: toString
};

function parse$1(indices, filepath, raw) {
  var i = {
    contents: 0
  };
  var fileType = parse(filepath);
  var preprocessed;
  switch (fileType) {
    case "Agda" :
        preprocessed = make(raw);
        break;
    case "LiterateTeX" :
        preprocessed = markWithRules(texBegin, texEnd, raw);
        break;
    case "LiterateRST" :
        preprocessed = markWithRules(rstBegin, rstEnd, raw);
        break;
    case "LiterateMarkdown" :
        preprocessed = markWithRules(markdown, markdown, raw);
        break;
    case "LiterateOrg" :
        preprocessed = markWithRules(orgBegin, orgEnd, raw);
        break;
    
  }
  var original = lex(goalQuestionMark, "GoalQMRaw", "GoalQM", lex(goalQuestionMarkRaw, "AgdaRaw", "GoalQMRaw", lex(goalBracket, "AgdaRaw", "GoalBracket", lex(comment, "AgdaRaw", "Comment", preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return {
            content: "{!   !}",
            range: token.range,
            kind: "GoalBracket"
          };
  };
  var adjustGoalBracket = function (token) {
    var idx = Belt_Array.get(indices, i.contents);
    var goalIndex = idx !== undefined ? String(idx) : "*";
    var requiredSpaces = goalIndex.length;
    var content = Belt_Option.getWithDefault(Belt_Option.flatMap(Caml_option.null_to_opt(goalBracketContent.exec(token.content)), (function (result) {
                return Belt_Option.flatMap(Belt_Option.map(Belt_Array.get(result, 1), (function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                })), (function (x) {
                              return x;
                            }));
              })), "");
    var actualSpaces = Belt_Option.getWithDefault(Belt_Option.flatMap((function (__x) {
                  return Js_string.match_(/\s*$/, __x);
                })(content), (function (matches) {
                var match = Belt_Array.get(matches, 0);
                if (match === undefined) {
                  return ;
                }
                var s = Caml_option.valFromOption(match);
                if (s !== undefined) {
                  return s.length;
                }
                
              })), 0);
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = Js_string.repeat(requiredSpaces - actualSpaces | 0, "");
      newContent = Js_string.replaceByRe(/\{!.*!\}/, "{!" + content + padding + "!}", token.content);
    } else {
      newContent = token.content;
    }
    i.contents = i.contents + 1 | 0;
    return {
            content: newContent,
            range: [
              1,
              2
            ],
            kind: "GoalBracket"
          };
  };
  var modified = mapOnly("GoalBracket", adjustGoalBracket, mapOnly("GoalQM", questionMark2GoalBracket, original));
  var originalHoles = Belt_Array.keep(original, isHole);
  var modifiedHoles = Belt_Array.keep(modified, isHole);
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(originalHoles, (function (idx, token) {
                    var match = Belt_Array.get(modifiedHoles, idx);
                    var match$1 = Belt_Array.get(indices, idx);
                    if (match === undefined) {
                      return ;
                    }
                    if (match$1 === undefined) {
                      return ;
                    }
                    var match$2 = match.range;
                    var start = match$2[0];
                    return {
                            index: match$1,
                            modifiedInterval: match.range,
                            originalInterval: [
                              start,
                              start + token.content.length | 0
                            ],
                            content: match.content,
                            changed: token.content !== match.content
                          };
                  })), (function (x) {
                return x;
              }));
}

exports.FileType = FileType;
exports.Token = Token;
exports.Lexer = Lexer;
exports.Regex = Regex;
exports.Literate = Literate;
exports.Diff = Diff;
exports.parse = parse$1;
/* Parser-AgdaModeVscode Not a pure module */
