// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var Tokens$AgdaModeVscode = require("./Tokens.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function make() {
  return {
          decorations: [],
          semanticTokens: []
        };
}

function clear(self) {
  Belt_Array.forEach(self.decorations, (function (param) {
          Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
}

function destroy(self) {
  clear(self);
}

function redecorate(self, editor) {
  Belt_Array.forEach(self.decorations, (function (param) {
          Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
        }));
}

function classify(change, token) {
  var removedRange = change.range;
  var lines = Parser$AgdaModeVscode.splitToLines(change.text);
  var lineDetalOfRemovedRange = removedRange.end.line - removedRange.start.line | 0;
  var lineDelta = (lines.length - 1 | 0) - lineDetalOfRemovedRange | 0;
  var match;
  if (lineDelta > 0) {
    match = [
      lineDelta,
      -removedRange.end.character | 0
    ];
  } else if (lineDelta < 0) {
    var columnDelta = removedRange.end.character - removedRange.start.character | 0;
    match = [
      lineDelta,
      -columnDelta | 0
    ];
  } else {
    var columnDeltaOfRemovedRange = removedRange.end.character - removedRange.start.character | 0;
    var line = Belt_Array.get(lines, lineDelta);
    var columnDelta$1 = line !== undefined ? line.length - columnDeltaOfRemovedRange | 0 : 0;
    match = [
      0,
      columnDelta$1
    ];
  }
  var lineDelta$1 = match[0];
  var tokenRange = Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange(token.range);
  if (tokenRange.end.isBeforeOrEqual(removedRange.start)) {
    return "NoOp";
  } else if (removedRange.contains(tokenRange) || tokenRange.start.isBefore(removedRange.start) && tokenRange.end.isAfter(removedRange.end)) {
    return "Remove";
  } else if (token.range.line === removedRange.end.line) {
    return {
            TAG: "Move",
            _0: lineDelta$1,
            _1: match[1],
            [Symbol.for("name")]: "Move"
          };
  } else if (lineDelta$1 === 0) {
    return "NoOp";
  } else {
    return {
            TAG: "MoveLinesOnly",
            _0: lineDelta$1,
            [Symbol.for("name")]: "MoveLinesOnly"
          };
  }
}

async function triggerDocumentChangeEvent(editor) {
  var $$document = editor.document;
  var lineCount = $$document.lineCount;
  var lastLine = $$document.lineAt(lineCount - 1 | 0);
  var insertPosition = lastLine.range.end;
  var deleteRange = new Vscode.Range(insertPosition, insertPosition.translate(0, 1));
  var succeed = await Editor$AgdaModeVscode.$$Text.insert($$document, insertPosition, " ");
  await (
    succeed ? Editor$AgdaModeVscode.$$Text.replace($$document, deleteRange, "") : Promise.resolve(false)
  );
  await $$document.save();
}

function updateSemanticHighlighting(self, $$event) {
  var changes = $$event.contentChanges;
  var applyChange = function (tokens, change) {
    return Belt_Array.concatMany(Belt_Array.map(tokens, (function (token) {
                      var action = classify(change, token);
                      if (typeof action !== "object") {
                        if (action === "NoOp") {
                          return [token];
                        } else {
                          return [];
                        }
                      }
                      if (action.TAG !== "Move") {
                        return [{
                                  range: {
                                    line: token.range.line + action._0 | 0,
                                    column: token.range.column
                                  },
                                  type_: token.type_,
                                  modifiers: token.modifiers
                                }];
                      }
                      var columnDelta = action._1;
                      return [{
                                range: {
                                  line: token.range.line + action._0 | 0,
                                  column: [
                                    PervasivesU.abs(token.range.column[0] + columnDelta | 0),
                                    PervasivesU.abs(token.range.column[1] + columnDelta | 0)
                                  ]
                                },
                                type_: token.type_,
                                modifiers: token.modifiers
                              }];
                    })));
  };
  Belt_Array.forEach(changes, (function (change) {
          self.semanticTokens = applyChange(self.semanticTokens, change);
        }));
}

function getSemanticTokens(self) {
  return self.semanticTokens;
}

function apply(self, tokens, editor) {
  if (Config$AgdaModeVscode.Highlighting.getHighlightWithThemeColors()) {
    var match = Tokens$AgdaModeVscode.toDecorationsAndSemanticTokens(tokens, editor);
    self.semanticTokens = match[1];
    self.decorations = Belt_Array.concat(self.decorations, match[0]);
    return triggerDocumentChangeEvent(editor);
  }
  var decorations = Tokens$AgdaModeVscode.toDecorations(tokens, editor);
  self.decorations = Belt_Array.concat(self.decorations, decorations);
  return Promise.resolve();
}

var Module = {
  make: make,
  destroy: destroy,
  decorateHole: decorateHole,
  apply: apply,
  clear: clear,
  redecorate: redecorate,
  updateSemanticHighlighting: updateSemanticHighlighting,
  getSemanticTokens: getSemanticTokens
};

var Decoration;

var SemanticToken;

exports.Decoration = Decoration;
exports.SemanticToken = SemanticToken;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.decorateHole = decorateHole;
exports.apply = apply;
exports.clear = clear;
exports.redecorate = redecorate;
exports.updateSemanticHighlighting = updateSemanticHighlighting;
exports.getSemanticTokens = getSemanticTokens;
/* vscode Not a pure module */
