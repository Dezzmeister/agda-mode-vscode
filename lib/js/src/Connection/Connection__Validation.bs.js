// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Nodechild_process = require("node:child_process");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "process hanging for more than 1 sec";
  }
  switch (x.TAG) {
    case "PathMalformed" :
        return "path malformed: " + x._0;
    case "NotFound" :
        return x._0;
    case "ShellError" :
        return "shell: " + Util$AgdaModeVscode.JsError.toString(x._0);
    case "ProcessError" :
        return "stderr: " + x._0;
    case "WrongProcess" :
        return "wrong process: " + x._0;
    
  }
}

var $$Error = {
  toString: toString
};

function run(path, args, validator) {
  var parseError = function (error) {
    return Core__Option.map((error == null) ? undefined : Caml_option.some(error), (function (err) {
                  var message = Core__Option.getOr(err.message, "");
                  if (/No such file or directory/.test(message) || /command not found/.test(message) || message.endsWith("ENOENT")) {
                    return {
                            TAG: "NotFound",
                            _0: message,
                            [Symbol.for("name")]: "NotFound"
                          };
                  } else {
                    return {
                            TAG: "ShellError",
                            _0: err,
                            [Symbol.for("name")]: "ShellError"
                          };
                  }
                }));
  };
  return new Promise((function (resolve, param) {
                if (path === "") {
                  resolve({
                        TAG: "Error",
                        _0: {
                          TAG: "PathMalformed",
                          _0: "the path must not be empty",
                          [Symbol.for("name")]: "PathMalformed"
                        },
                        [Symbol.for("name")]: "Error"
                      });
                }
                var match = Util$AgdaModeVscode.onUnix ? [
                    path,
                    args
                  ] : (
                    path.endsWith(".bat") ? [
                        "cmd.exe",
                        Belt_Array.concatMany([
                              [
                                "/c",
                                path
                              ],
                              args
                            ])
                      ] : (
                        path.endsWith(".exe") ? [
                            path,
                            args
                          ] : [
                            path + ".exe",
                            args
                          ]
                      )
                  );
                var hangTimeout = setTimeout((function () {
                        resolve({
                              TAG: "Error",
                              _0: "ProcessHanging",
                              [Symbol.for("name")]: "Error"
                            });
                      }), 20000);
                Nodechild_process.execFile(match[0], match[1], (function (error, stdout, stderr) {
                        clearTimeout(hangTimeout);
                        Belt_Option.forEach(parseError(error), (function (err) {
                                resolve({
                                      TAG: "Error",
                                      _0: err,
                                      [Symbol.for("name")]: "Error"
                                    });
                              }));
                        var stderr$1 = stderr.toString();
                        if (stderr$1 !== "") {
                          resolve({
                                TAG: "Error",
                                _0: {
                                  TAG: "ProcessError",
                                  _0: stderr$1,
                                  [Symbol.for("name")]: "ProcessError"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                        }
                        var stdout$1 = stdout.toString();
                        var err = validator(stdout$1);
                        if (err.TAG === "Ok") {
                          return resolve({
                                      TAG: "Ok",
                                      _0: err._0,
                                      [Symbol.for("name")]: "Ok"
                                    });
                        } else {
                          return resolve({
                                      TAG: "Error",
                                      _0: {
                                        TAG: "WrongProcess",
                                        _0: err._0,
                                        [Symbol.for("name")]: "WrongProcess"
                                      },
                                      [Symbol.for("name")]: "Error"
                                    });
                        }
                      }));
              }));
}

exports.$$Error = $$Error;
exports.run = run;
/* node:child_process Not a pure module */
