// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Nodechild_process = require("node:child_process");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Connection__Target__Agda__Process$AgdaModeVscode = require("./Target/Agda/Connection__Target__Agda__Process.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "process hanging for more than 1 sec";
  }
  switch (x.TAG) {
    case "PathMalformed" :
        return "path malformed: " + x._0;
    case "NotFound" :
        return "command not found: " + x._0;
    case "ShellError" :
        return "shell: " + Util$AgdaModeVscode.JsError.toString(x._0);
    case "FromStderr" :
        return "stderr: " + x._0;
    case "FromOnError" :
        return "on error: " + x._0;
    case "WrongProcess" :
        return "wrong process: " + x._0;
    
  }
}

var $$Error = {
  toString: toString
};

function handleError(command, error) {
  return Core__Option.map((error == null) ? undefined : Caml_option.some(error), (function (err) {
                var message = Core__Option.getOr(err.message, "");
                if (/command not found/.test(message) || /No such file or directory/.test(message) || /not found/.test(message) || message.endsWith("ENOENT")) {
                  return {
                          TAG: "NotFound",
                          _0: command,
                          [Symbol.for("name")]: "NotFound"
                        };
                } else {
                  return {
                          TAG: "ShellError",
                          _0: err,
                          [Symbol.for("name")]: "ShellError"
                        };
                }
              }));
}

async function run3(path, args) {
  var $$process = Connection__Target__Agda__Process$AgdaModeVscode.make(path, args);
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var stdout = {
    contents: ""
  };
  var stderr = {
    contents: ""
  };
  var destructor = Connection__Target__Agda__Process$AgdaModeVscode.onOutput($$process, (function (output) {
          switch (output.TAG) {
            case "Stdout" :
                stdout.contents = stdout.contents + output._0;
                return ;
            case "Stderr" :
                stderr.contents = stderr.contents + output._0;
                return ;
            case "Event" :
                var msg = output._0;
                if (typeof msg !== "object") {
                  return resolve({
                              TAG: "Ok",
                              _0: stdout.contents,
                              [Symbol.for("name")]: "Ok"
                            });
                }
                if (msg.TAG === "OnError") {
                  var msg$1 = msg._0;
                  if (msg$1 !== "") {
                    if (Connection__Target__Agda__Process$AgdaModeVscode.errorMessageIndicatesNotFound(msg$1)) {
                      return resolve({
                                  TAG: "Error",
                                  _0: {
                                    TAG: "NotFound",
                                    _0: path,
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "Error"
                                });
                    } else {
                      return resolve({
                                  TAG: "Error",
                                  _0: {
                                    TAG: "FromOnError",
                                    _0: msg$1,
                                    [Symbol.for("name")]: "FromOnError"
                                  },
                                  [Symbol.for("name")]: "Error"
                                });
                    }
                  } else if (stderr.contents !== "") {
                    if (Connection__Target__Agda__Process$AgdaModeVscode.errorMessageIndicatesNotFound(stderr.contents)) {
                      return resolve({
                                  TAG: "Error",
                                  _0: {
                                    TAG: "NotFound",
                                    _0: path,
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "Error"
                                });
                    } else {
                      return resolve({
                                  TAG: "Error",
                                  _0: {
                                    TAG: "FromStderr",
                                    _0: stderr.contents,
                                    [Symbol.for("name")]: "FromStderr"
                                  },
                                  [Symbol.for("name")]: "Error"
                                });
                    }
                  } else {
                    return resolve({
                                TAG: "Ok",
                                _0: stdout.contents,
                                [Symbol.for("name")]: "Ok"
                              });
                  }
                }
                var exitCode = msg._2;
                if (exitCode !== 0) {
                  if (stderr.contents !== "") {
                    if (Connection__Target__Agda__Process$AgdaModeVscode.errorMessageIndicatesNotFound(stderr.contents)) {
                      return resolve({
                                  TAG: "Error",
                                  _0: {
                                    TAG: "NotFound",
                                    _0: path,
                                    [Symbol.for("name")]: "NotFound"
                                  },
                                  [Symbol.for("name")]: "Error"
                                });
                    } else {
                      return resolve({
                                  TAG: "Error",
                                  _0: {
                                    TAG: "FromStderr",
                                    _0: stderr.contents,
                                    [Symbol.for("name")]: "FromStderr"
                                  },
                                  [Symbol.for("name")]: "Error"
                                });
                    }
                  } else {
                    return resolve({
                                TAG: "Ok",
                                _0: "stdout.contents [1], exited with " + String(exitCode) + ", stdout: " + stdout.contents,
                                [Symbol.for("name")]: "Ok"
                              });
                  }
                } else {
                  return resolve({
                              TAG: "Ok",
                              _0: stdout.contents,
                              [Symbol.for("name")]: "Ok"
                            });
                }
            
          }
        }));
  var result = await match[0];
  destructor();
  return result;
}

function run(path, args) {
  return new Promise((function (resolve, param) {
                if (path === "") {
                  resolve({
                        TAG: "Error",
                        _0: {
                          TAG: "PathMalformed",
                          _0: "the path must not be empty",
                          [Symbol.for("name")]: "PathMalformed"
                        },
                        [Symbol.for("name")]: "Error"
                      });
                }
                var match = Util$AgdaModeVscode.onUnix || !path.endsWith(".bat") ? [
                    path,
                    args
                  ] : [
                    "cmd.exe",
                    Belt_Array.concatMany([
                          [
                            "/c",
                            path
                          ],
                          args
                        ])
                  ];
                var hangTimeout = setTimeout((function () {
                        resolve({
                              TAG: "Error",
                              _0: "ProcessHanging",
                              [Symbol.for("name")]: "Error"
                            });
                      }), 20000);
                var command = Belt_Array.concatMany([
                        [match[0]],
                        match[1]
                      ]).join(" ");
                Nodechild_process.exec(command, {shell : true}, (function (error, stdout, stderr) {
                        clearTimeout(hangTimeout);
                        Core__Option.forEach(handleError(command, error), (function (err) {
                                resolve({
                                      TAG: "Error",
                                      _0: err,
                                      [Symbol.for("name")]: "Error"
                                    });
                              }));
                        var stderr$1 = stderr.toString();
                        if (stderr$1 !== "") {
                          resolve({
                                TAG: "Error",
                                _0: {
                                  TAG: "FromStderr",
                                  _0: stderr$1,
                                  [Symbol.for("name")]: "FromStderr"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                        }
                        var stdout$1 = stdout.toString();
                        resolve({
                              TAG: "Ok",
                              _0: stdout$1,
                              [Symbol.for("name")]: "Ok"
                            });
                      }));
              }));
}

function run2(path, args, validator) {
  return new Promise((function (resolve, param) {
                if (path === "") {
                  resolve({
                        TAG: "Error",
                        _0: {
                          TAG: "PathMalformed",
                          _0: "the path must not be empty",
                          [Symbol.for("name")]: "PathMalformed"
                        },
                        [Symbol.for("name")]: "Error"
                      });
                }
                var match = Util$AgdaModeVscode.onUnix || !path.endsWith(".bat") ? [
                    path,
                    args
                  ] : [
                    "cmd.exe",
                    Belt_Array.concatMany([
                          [
                            "/c",
                            path
                          ],
                          args
                        ])
                  ];
                var command = match[0];
                var hangTimeout = setTimeout((function () {
                        resolve({
                              TAG: "Error",
                              _0: "ProcessHanging",
                              [Symbol.for("name")]: "Error"
                            });
                      }), 20000);
                Nodechild_process.execFile(command, match[1], (function (error, stdout, stderr) {
                        clearTimeout(hangTimeout);
                        Core__Option.forEach(handleError(command, error), (function (err) {
                                resolve({
                                      TAG: "Error",
                                      _0: err,
                                      [Symbol.for("name")]: "Error"
                                    });
                              }));
                        var stderr$1 = stderr.toString();
                        if (stderr$1 !== "") {
                          resolve({
                                TAG: "Error",
                                _0: {
                                  TAG: "FromStderr",
                                  _0: stderr$1,
                                  [Symbol.for("name")]: "FromStderr"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                        }
                        var stdout$1 = stdout.toString();
                        var err = validator(stdout$1);
                        if (err.TAG === "Ok") {
                          return resolve({
                                      TAG: "Ok",
                                      _0: err._0,
                                      [Symbol.for("name")]: "Ok"
                                    });
                        } else {
                          return resolve({
                                      TAG: "Error",
                                      _0: {
                                        TAG: "WrongProcess",
                                        _0: err._0,
                                        [Symbol.for("name")]: "WrongProcess"
                                      },
                                      [Symbol.for("name")]: "Error"
                                    });
                        }
                      }));
              }));
}

exports.$$Error = $$Error;
exports.handleError = handleError;
exports.run3 = run3;
exports.run = run;
exports.run2 = run2;
/* node:child_process Not a pure module */
