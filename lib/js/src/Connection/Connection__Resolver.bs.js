// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodepath = require("node:path");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Connection__Resolver__TCP$AgdaModeVscode = require("./Resolver/Connection__Resolver__TCP.bs.js");
var Connection__Resolver__File$AgdaModeVscode = require("./Resolver/Connection__Resolver__File.bs.js");
var Connection__Resolver__GitHub$AgdaModeVscode = require("./Resolver/Connection__Resolver__GitHub.bs.js");
var Connection__Resolver__Command$AgdaModeVscode = require("./Resolver/Connection__Resolver__Command.bs.js");

function toString(error) {
  switch (error.TAG) {
    case "File" :
        return "Trying to locate \"" + error._0 + "\" but the file does not exist";
    case "Command" :
        return "Trying to find the command \"" + error._0 + "\": " + Connection__Resolver__Command$AgdaModeVscode.$$Error.toString(error._1);
    case "TCP" :
        return "Trying to connect to " + error._1 + ":" + String(error._0) + " : " + Connection__Resolver__TCP$AgdaModeVscode.$$Error.toString(error._2);
    case "GitHub" :
        return "Trying to download prebuilt from GitHub: " + Connection__Resolver__GitHub$AgdaModeVscode.$$Error.toString(error._0);
    
  }
}

var $$Error = {
  toString: toString
};

async function search(source, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  switch (source.TAG) {
    case "FromFile" :
        var path = source._0;
        if (Connection__Resolver__File$AgdaModeVscode.probe(path)) {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ViaPipe",
                    _0: path,
                    _1: [],
                    _2: undefined,
                    _3: {
                      TAG: "FromFile",
                      _0: path,
                      [Symbol.for("name")]: "FromFile"
                    },
                    [Symbol.for("name")]: "ViaPipe"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "File",
                    _0: path,
                    [Symbol.for("name")]: "File"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
    case "FromCommand" :
        var name = source._0;
        var e = await Connection__Resolver__Command$AgdaModeVscode.search(name, timeout);
        if (e.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ViaPipe",
                    _0: e._0,
                    _1: [],
                    _2: undefined,
                    _3: {
                      TAG: "FromCommand",
                      _0: name,
                      [Symbol.for("name")]: "FromCommand"
                    },
                    [Symbol.for("name")]: "ViaPipe"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "Command",
                    _0: name,
                    _1: e._0,
                    [Symbol.for("name")]: "Command"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
    case "FromTCP" :
        var host = source._1;
        var port = source._0;
        var e$1 = await Connection__Resolver__TCP$AgdaModeVscode.probe(port, host, timeout);
        if (e$1.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ViaTCP",
                    _0: port,
                    _1: host,
                    _2: {
                      TAG: "FromTCP",
                      _0: port,
                      _1: host,
                      [Symbol.for("name")]: "FromTCP"
                    },
                    [Symbol.for("name")]: "ViaTCP"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "TCP",
                    _0: port,
                    _1: host,
                    _2: e$1._0,
                    [Symbol.for("name")]: "TCP"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
    case "FromGitHub" :
        var callbacks = source._1;
        var repo = source._0;
        var e$2 = await Connection__Resolver__GitHub$AgdaModeVscode.get(repo, callbacks);
        if (e$2.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "GitHub",
                    _0: e$2._0,
                    [Symbol.for("name")]: "GitHub"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
        var match = e$2._0;
        var target = match[1];
        var destPath = Nodepath.join(repo.globalStoragePath, target.saveAsFileName);
        var e$3 = await callbacks.afterDownload(match[0], [
              destPath,
              target
            ]);
        if (e$3.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "GitHub",
                    _0: e$3._0,
                    [Symbol.for("name")]: "GitHub"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
        var match$1 = e$3._0;
        var target$1 = match$1[3];
        return {
                TAG: "Ok",
                _0: {
                  TAG: "ViaPipe",
                  _0: match$1[0],
                  _1: match$1[1],
                  _2: match$1[2],
                  _3: {
                    TAG: "FromGitHub",
                    _0: repo,
                    _1: target$1.release,
                    _2: target$1.asset,
                    [Symbol.for("name")]: "FromGitHub"
                  },
                  [Symbol.for("name")]: "ViaPipe"
                },
                [Symbol.for("name")]: "Ok"
              };
    
  }
}

async function searchUntilSuccess(sources) {
  var tryUntilSuccess = async function (accumErrors, input) {
    if (!input) {
      return [
              undefined,
              /* [] */0
            ];
    }
    var xs = input.tl;
    var x = input.hd;
    if (xs) {
      var e = await search(x, undefined);
      if (e.TAG === "Ok") {
        return [
                e._0,
                accumErrors
              ];
      }
      var match = await tryUntilSuccess(accumErrors, xs);
      return [
              match[0],
              {
                hd: e._0,
                tl: match[1]
              }
            ];
    }
    var e$1 = await search(x, undefined);
    if (e$1.TAG === "Ok") {
      return [
              e$1._0,
              /* [] */0
            ];
    } else {
      return [
              undefined,
              {
                hd: e$1._0,
                tl: /* [] */0
              }
            ];
    }
  };
  var match = await tryUntilSuccess(/* [] */0, Core__List.fromArray(sources));
  return [
          match[0],
          Core__List.toArray(match[1])
        ];
}

function consumeResult(param) {
  var result = param[0];
  if (result !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(result),
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: param[1],
            [Symbol.for("name")]: "Error"
          };
  }
}

var Module = {
  search: search,
  searchUntilSuccess: searchUntilSuccess,
  consumeResult: consumeResult
};

var Command;

var $$File;

var TCP;

var GitHub;

var IPC;

exports.Command = Command;
exports.$$File = $$File;
exports.TCP = TCP;
exports.GitHub = GitHub;
exports.IPC = IPC;
exports.$$Error = $$Error;
exports.Module = Module;
exports.search = search;
exports.searchUntilSuccess = searchUntilSuccess;
exports.consumeResult = consumeResult;
/* node:path Not a pure module */
