// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodeos = require("node:os");
var Nodepath = require("node:path");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Connection__Resolver__TCP$AgdaModeVscode = require("./Resolver/Connection__Resolver__TCP.bs.js");
var Connection__Resolver__File$AgdaModeVscode = require("./Resolver/Connection__Resolver__File.bs.js");
var Connection__Resolver__GitHub$AgdaModeVscode = require("./Resolver/Connection__Resolver__GitHub.bs.js");
var Connection__Resolver__Command$AgdaModeVscode = require("./Resolver/Connection__Resolver__Command.bs.js");

function toString(error) {
  switch (error.TAG) {
    case "File" :
        return "Trying to locate \"" + error._0 + "\" but the file does not exist";
    case "Command" :
        return "Trying to find the command \"" + error._0 + "\": " + Connection__Resolver__Command$AgdaModeVscode.$$Error.toString(error._1);
    case "TCP" :
        return "Trying to connect to " + error._1 + ":" + String(error._0) + " : " + Connection__Resolver__TCP$AgdaModeVscode.$$Error.toString(error._2);
    case "GitHub" :
        return "Trying to download prebuilt from GitHub: " + Connection__Resolver__GitHub$AgdaModeVscode.$$Error.toString(error._0);
    
  }
}

var $$Error = {
  toString: toString
};

async function search(source, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  switch (source.TAG) {
    case "FromFile" :
        var path = source._0;
        if (Connection__Resolver__File$AgdaModeVscode.probe(path)) {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ViaPipe",
                    _0: path,
                    _1: [],
                    _2: undefined,
                    _3: {
                      TAG: "FromFile",
                      _0: path,
                      [Symbol.for("name")]: "FromFile"
                    },
                    [Symbol.for("name")]: "ViaPipe"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "File",
                    _0: path,
                    [Symbol.for("name")]: "File"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
    case "FromCommand" :
        var name = source._0;
        var e = await Connection__Resolver__Command$AgdaModeVscode.search(name, timeout);
        if (e.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ViaPipe",
                    _0: e._0,
                    _1: [],
                    _2: undefined,
                    _3: {
                      TAG: "FromCommand",
                      _0: name,
                      [Symbol.for("name")]: "FromCommand"
                    },
                    [Symbol.for("name")]: "ViaPipe"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "Command",
                    _0: name,
                    _1: e._0,
                    [Symbol.for("name")]: "Command"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
    case "FromTCP" :
        var host = source._1;
        var port = source._0;
        var e$1 = await Connection__Resolver__TCP$AgdaModeVscode.probe(port, host, timeout);
        if (e$1.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ViaTCP",
                    _0: port,
                    _1: host,
                    _2: {
                      TAG: "FromTCP",
                      _0: port,
                      _1: host,
                      [Symbol.for("name")]: "FromTCP"
                    },
                    [Symbol.for("name")]: "ViaTCP"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "TCP",
                    _0: port,
                    _1: host,
                    _2: e$1._0,
                    [Symbol.for("name")]: "TCP"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
    case "FromGitHub" :
        var callbacks = source._1;
        var repo = source._0;
        var e$2 = await Connection__Resolver__GitHub$AgdaModeVscode.get(repo, callbacks);
        if (e$2.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "GitHub",
                    _0: e$2._0,
                    [Symbol.for("name")]: "GitHub"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
        var match = e$2._0;
        var target = match[1];
        var destPath = Nodepath.join(repo.globalStoragePath, target.saveAsFileName);
        var e$3 = await callbacks.afterDownload(match[0], [
              destPath,
              target
            ]);
        if (e$3.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "GitHub",
                    _0: e$3._0,
                    [Symbol.for("name")]: "GitHub"
                  },
                  [Symbol.for("name")]: "Error"
                };
        }
        var match$1 = e$3._0;
        var target$1 = match$1[3];
        return {
                TAG: "Ok",
                _0: {
                  TAG: "ViaPipe",
                  _0: match$1[0],
                  _1: match$1[1],
                  _2: match$1[2],
                  _3: {
                    TAG: "FromGitHub",
                    _0: repo,
                    _1: target$1.release,
                    _2: target$1.asset,
                    [Symbol.for("name")]: "FromGitHub"
                  },
                  [Symbol.for("name")]: "ViaPipe"
                },
                [Symbol.for("name")]: "Ok"
              };
    
  }
}

async function searchMany(sources) {
  var tryUntilSuccess = async function (accumErrors, input) {
    if (!input) {
      return [
              undefined,
              /* [] */0
            ];
    }
    var xs = input.tl;
    var x = input.hd;
    if (xs) {
      var e = await search(x, undefined);
      if (e.TAG === "Ok") {
        return [
                e._0,
                accumErrors
              ];
      }
      var match = await tryUntilSuccess(accumErrors, xs);
      return [
              match[0],
              {
                hd: e._0,
                tl: match[1]
              }
            ];
    }
    var e$1 = await search(x, undefined);
    if (e$1.TAG === "Ok") {
      return [
              e$1._0,
              /* [] */0
            ];
    } else {
      return [
              undefined,
              {
                hd: e$1._0,
                tl: /* [] */0
              }
            ];
    }
  };
  var match = await tryUntilSuccess(/* [] */0, Core__List.fromArray(sources));
  return [
          match[0],
          Core__List.toArray(match[1])
        ];
}

async function afterDownload(isCached, param) {
  var path = param[0];
  var assetPath = Nodepath.join(path, "data");
  var env = Object.fromEntries([[
          "Agda_datadir",
          assetPath
        ]]);
  var options_env = env;
  var options = {
    env: options_env
  };
  var execPath = Nodepath.join(path, "als");
  var shouldChmod = !isCached && Nodeos.platform() !== "win32";
  if (shouldChmod) {
    await Connection__Resolver__GitHub$AgdaModeVscode.chmodExecutable(execPath);
  }
  return {
          TAG: "Ok",
          _0: [
            execPath,
            [],
            options,
            param[1]
          ],
          [Symbol.for("name")]: "Ok"
        };
}

function chooseFromReleases(releases) {
  var match = Nodeos.platform();
  var platform;
  switch (match) {
    case "darwin" :
        var match$1 = Nodeos.arch();
        switch (match$1) {
          case "arm64" :
              platform = "macos-arm64";
              break;
          case "x64" :
              platform = "macos-x64";
              break;
          default:
            platform = undefined;
        }
        break;
    case "linux" :
        platform = "ubuntu";
        break;
    case "win32" :
        platform = "windows";
        break;
    default:
      platform = undefined;
  }
  var release = Connection__Resolver__GitHub$AgdaModeVscode.Release.chooseLatest(releases);
  if (release === undefined) {
    return ;
  }
  if (platform === undefined) {
    return ;
  }
  var expectedAssetName = "als-" + platform + ".zip";
  var asset = Connection__Resolver__GitHub$AgdaModeVscode.Asset.chooseByName(release.assets, expectedAssetName);
  if (asset !== undefined) {
    return {
            release: release,
            asset: asset,
            saveAsFileName: release.tag_name + "-" + platform
          };
  }
  
}

function makeAgdaLanguageServerRepo(globalStoragePath) {
  return {
          username: "agda",
          repository: "agda-language-server",
          userAgent: "agda/agda-mode-vscode",
          globalStoragePath: globalStoragePath,
          cacheInvalidateExpirationSecs: 86400
        };
}

async function tryALS(globalStoragePath, onDownload) {
  var port = Config$AgdaModeVscode.Connection.getAgdaLanguageServerPort();
  return await searchMany([
              {
                TAG: "FromTCP",
                _0: port,
                _1: "localhost",
                [Symbol.for("name")]: "FromTCP"
              },
              {
                TAG: "FromCommand",
                _0: "als",
                [Symbol.for("name")]: "FromCommand"
              },
              {
                TAG: "FromGitHub",
                _0: makeAgdaLanguageServerRepo(globalStoragePath),
                _1: {
                  chooseFromReleases: chooseFromReleases,
                  onDownload: onDownload,
                  afterDownload: afterDownload,
                  log: (function (x) {
                      console.log(x);
                    })
                },
                [Symbol.for("name")]: "FromGitHub"
              }
            ]);
}

function tryAgda() {
  var storedPath = Config$AgdaModeVscode.Connection.getAgdaPath();
  var storedName = Config$AgdaModeVscode.Connection.getAgdaVersion();
  return searchMany([
              {
                TAG: "FromFile",
                _0: storedPath,
                [Symbol.for("name")]: "FromFile"
              },
              {
                TAG: "FromCommand",
                _0: storedName,
                [Symbol.for("name")]: "FromCommand"
              }
            ]);
}

var Module = {
  search: search,
  searchMany: searchMany,
  tryALS: tryALS,
  tryAgda: tryAgda
};

var Command;

var $$File;

var TCP;

var GitHub;

var IPC;

exports.Command = Command;
exports.$$File = $$File;
exports.TCP = TCP;
exports.GitHub = GitHub;
exports.IPC = IPC;
exports.$$Error = $$Error;
exports.Module = Module;
exports.search = search;
exports.searchMany = searchMany;
exports.tryALS = tryALS;
exports.tryAgda = tryAgda;
/* node:os Not a pure module */
