// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Caml = require("rescript/lib/js/caml.js");
var Getos = require("getos");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Nodefs = require("node:fs");
var Js_array = require("rescript/lib/js/js_array.js");
var Nodeurl = require("node:url");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var State__Type$AgdaModeVscode = require("../../State/State__Type.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var Json_Encode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Encode.bs.js");
var Connection__Resolver__GitHub__Unzip$AgdaModeVscode = require("./GitHub/Connection__Resolver__GitHub__Unzip.bs.js");
var Connection__Resolver__GitHub__Download$AgdaModeVscode = require("./GitHub/Connection__Resolver__GitHub__Download.bs.js");

function unlink(path) {
  return new Promise((function (resolve, param) {
                Fs.unlink(path, (function (error) {
                        if (error !== null) {
                          return resolve({
                                      TAG: "Error",
                                      _0: error,
                                      [Symbol.for("name")]: "Error"
                                    });
                        } else {
                          return resolve({
                                      TAG: "Ok",
                                      _0: undefined,
                                      [Symbol.for("name")]: "Ok"
                                    });
                        }
                      }));
              }));
}

function rename(old, $$new) {
  return new Promise((function (resolve, param) {
                Fs.rename(old, $$new, (function (error) {
                        if (error !== null) {
                          return resolve({
                                      TAG: "Error",
                                      _0: error,
                                      [Symbol.for("name")]: "Error"
                                    });
                        } else {
                          return resolve({
                                      TAG: "Ok",
                                      _0: undefined,
                                      [Symbol.for("name")]: "Ok"
                                    });
                        }
                      }));
              }));
}

async function readFile(filepath) {
  var fileHandle = await Nodefs.promises.open(filepath, "r");
  var buffer = await fileHandle.readFile();
  await fileHandle.close();
  return buffer.toString();
}

async function writeFile(filepath, string) {
  var fileHandle = await Nodefs.promises.open(filepath, "w");
  await fileHandle.writeFile(Buffer.from(string));
  return await fileHandle.close();
}

var Fs$1 = {
  unlink: unlink,
  rename: rename,
  readFile: readFile,
  writeFile: writeFile
};

var Nd = {
  Fs: Fs$1
};

function toString(x) {
  if (typeof x !== "object") {
    if (x === "NoMatchingRelease") {
      return "Cannot find matching release from GitHub";
    } else {
      return "Already downloading";
    }
  }
  switch (x.TAG) {
    case "ResponseDecodeError" :
        return "Cannot decode release metadata JSON from GitHub:\n" + x._0;
    case "CannotDownload" :
        return "Cannot downlaod file from GitHub:\n" + Connection__Resolver__GitHub__Download$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotGetReleases" :
        return "Cannot get release info from GitHub:\n" + Connection__Resolver__GitHub__Download$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotReadReleasesCache" :
        return "Cannot read releases cache:\n" + x._0;
    case "CannotCacheReleases" :
        return "Failed to cache releases:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotChmodFile" :
        return "Cannot chmod file \"" + x._0 + "\"";
    case "CannotStatFile" :
        return "Cannot stat file \"" + x._0 + "\"";
    case "CannotReadFile" :
        return "Cannot to read files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotDeleteFile" :
        return "Cannot to delete files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotRenameFile" :
        return "Cannot to rename files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotDetermineOS" :
        return "Cannot determine OS:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1(asset) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "url",
                        asset.url
                      ],
                      [
                        "id",
                        String(asset.id)
                      ],
                      [
                        "node_id",
                        asset.node_id
                      ],
                      [
                        "name",
                        asset.name
                      ],
                      [
                        "label",
                        asset.label
                      ],
                      [
                        "content_type",
                        asset.content_type
                      ],
                      [
                        "state",
                        asset.state
                      ],
                      [
                        "size",
                        String(asset.size)
                      ],
                      [
                        "created_at",
                        asset.created_at
                      ],
                      [
                        "updated_at",
                        asset.updated_at
                      ],
                      [
                        "browser_download_url",
                        asset.browser_download_url
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var decode = Json_Decode$JsonCombinators.object(function (field) {
      return {
              url: field.required("url", Json_Decode$JsonCombinators.string),
              id: field.required("id", Json_Decode$JsonCombinators.$$int),
              node_id: field.required("node_id", Json_Decode$JsonCombinators.string),
              name: field.required("name", Json_Decode$JsonCombinators.string),
              label: field.required("label", Json_Decode$JsonCombinators.string),
              content_type: field.required("content_type", Json_Decode$JsonCombinators.string),
              state: field.required("state", Json_Decode$JsonCombinators.string),
              size: field.required("size", Json_Decode$JsonCombinators.$$int),
              created_at: field.required("created_at", Json_Decode$JsonCombinators.string),
              updated_at: field.required("updated_at", Json_Decode$JsonCombinators.string),
              browser_download_url: field.required("browser_download_url", Json_Decode$JsonCombinators.string)
            };
    });

function encode(asset) {
  return {
          url: asset.url,
          id: asset.id,
          node_id: asset.node_id,
          name: asset.name,
          label: asset.label,
          content_type: asset.content_type,
          state: asset.state,
          size: asset.size,
          created_at: asset.created_at,
          updated_at: asset.updated_at,
          browser_download_url: asset.browser_download_url
        };
}

function chooseByName(assets, name) {
  return assets.find(function (asset) {
              return asset.name === name;
            });
}

var Asset = {
  toString: toString$1,
  decode: decode,
  encode: encode,
  chooseByName: chooseByName
};

function toString$2(release) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "url",
                        release.url
                      ],
                      [
                        "assets_url",
                        release.assets_url
                      ],
                      [
                        "upload_url",
                        release.upload_url
                      ],
                      [
                        "html_url",
                        release.html_url
                      ],
                      [
                        "id",
                        String(release.id)
                      ],
                      [
                        "node_id",
                        release.node_id
                      ],
                      [
                        "tag_name",
                        release.tag_name
                      ],
                      [
                        "target_commitish",
                        release.target_commitish
                      ],
                      [
                        "name",
                        release.name
                      ],
                      [
                        "draft",
                        PervasivesU.string_of_bool(release.draft)
                      ],
                      [
                        "prerelease",
                        PervasivesU.string_of_bool(release.prerelease)
                      ],
                      [
                        "created_at",
                        release.created_at
                      ],
                      [
                        "published_at",
                        release.published_at
                      ],
                      [
                        "assets",
                        release.assets.map(toString$1).join(", ")
                      ],
                      [
                        "tarball_url",
                        release.tarball_url
                      ],
                      [
                        "zipball_url",
                        release.zipball_url
                      ],
                      [
                        "body",
                        Core__Option.getOr(Core__Option.map(release.body, (function (s) {
                                    return "\"" + s + "\"";
                                  })), "null")
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var decode$1 = Json_Decode$JsonCombinators.object(function (field) {
      return {
              url: field.required("url", Json_Decode$JsonCombinators.string),
              assets_url: field.required("assets_url", Json_Decode$JsonCombinators.string),
              upload_url: field.required("upload_url", Json_Decode$JsonCombinators.string),
              html_url: field.required("html_url", Json_Decode$JsonCombinators.string),
              id: field.required("id", Json_Decode$JsonCombinators.$$int),
              node_id: field.required("node_id", Json_Decode$JsonCombinators.string),
              tag_name: field.required("tag_name", Json_Decode$JsonCombinators.string),
              target_commitish: field.required("target_commitish", Json_Decode$JsonCombinators.string),
              name: field.required("name", Json_Decode$JsonCombinators.string),
              draft: field.required("draft", Json_Decode$JsonCombinators.bool),
              prerelease: field.required("prerelease", Json_Decode$JsonCombinators.bool),
              created_at: field.required("created_at", Json_Decode$JsonCombinators.string),
              published_at: field.required("published_at", Json_Decode$JsonCombinators.string),
              assets: field.required("assets", Json_Decode$JsonCombinators.array(decode)),
              tarball_url: field.required("tarball_url", Json_Decode$JsonCombinators.string),
              zipball_url: field.required("zipball_url", Json_Decode$JsonCombinators.string),
              body: field.required("body", Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.string))
            };
    });

function encode$1(release) {
  return {
          url: release.url,
          assets_url: release.assets_url,
          upload_url: release.upload_url,
          html_url: release.html_url,
          id: release.id,
          node_id: release.node_id,
          tag_name: release.tag_name,
          target_commitish: release.target_commitish,
          name: release.name,
          draft: release.draft,
          prerelease: release.prerelease,
          created_at: release.created_at,
          published_at: release.published_at,
          assets: Json_Encode$JsonCombinators.array(encode)(release.assets),
          tarball_url: release.tarball_url,
          zipball_url: release.zipball_url,
          body: Json_Encode$JsonCombinators.option(function (prim) {
                  return prim;
                })(release.body)
        };
}

function encodeReleases(releases) {
  return Json_Encode$JsonCombinators.array(encode$1)(releases);
}

function decodeReleases(json) {
  var releases = Json$JsonCombinators.decode(json, Json_Decode$JsonCombinators.array(decode$1));
  if (releases.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: releases._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "ResponseDecodeError",
              _0: releases._0,
              _1: json,
              [Symbol.for("name")]: "ResponseDecodeError"
            },
            [Symbol.for("name")]: "Error"
          };
  }
}

function chooseByTagName(releases, tagName) {
  return releases.find(function (release) {
              return release.tag_name === tagName;
            });
}

function chooseLatest(releases) {
  var compare = function (x, y) {
    var xTime = new Date(x.created_at).getTime();
    var yTime = new Date(y.created_at).getTime();
    return Caml.float_compare(yTime, xTime);
  };
  var sorted = Js_array.sortInPlaceWith(compare, releases);
  return sorted[0];
}

var Release = {
  toString: toString$2,
  decode: decode$1,
  encode: encode$1,
  encodeReleases: encodeReleases,
  decodeReleases: decodeReleases,
  chooseByTagName: chooseByTagName,
  chooseLatest: chooseLatest
};

var Target = {};

async function chmodExecutable(path) {
  try {
    await Nodefs.promises.chmod(path, 484);
    return {
            TAG: "Ok",
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotChmodFile",
                _0: path,
                [Symbol.for("name")]: "CannotChmodFile"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw exn;
  }
}

function determine() {
  var match = Util$AgdaModeVscode.Promise_.pending();
  var reject = match[2];
  var resolve = match[1];
  Getos(function (e, os) {
        if (e == null) {
          return resolve(os);
        } else {
          return reject(e);
        }
      });
  return match[0];
}

var Platform = {
  determine: determine
};

function toString$3(self) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "username",
                        self.username
                      ],
                      [
                        "repository",
                        self.repository
                      ],
                      [
                        "userAgent",
                        self.userAgent
                      ],
                      [
                        "globalStoragePath",
                        self.globalStoragePath
                      ],
                      [
                        "cacheInvalidateExpirationSecs",
                        String(self.cacheInvalidateExpirationSecs)
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var Repo = {
  toString: toString$3
};

var Callbacks = {};

var inFlightDownloadFileName = "in-flight.download";

async function isDownloading(globalStoragePath) {
  try {
    var exists;
    try {
      await Nodefs.promises.access(globalStoragePath);
      exists = true;
    }
    catch (exn){
      exists = false;
    }
    if (exists) {
      var inFlightDownloadPath = Nodepath.join(globalStoragePath, inFlightDownloadFileName);
      var fileNames = await Nodefs.promises.readdir(globalStoragePath);
      var matched = fileNames.filter(function (fileName) {
            return fileName === inFlightDownloadPath;
          });
      return Core__Option.isSome(matched[0]);
    }
    await Nodefs.promises.mkdir(globalStoragePath, {
          mode: 511
        });
    return false;
  }
  catch (exn$1){
    return false;
  }
}

async function downloadLanguageServer(repo, callbacks, target) {
  var url = new Nodeurl.URL(target.asset.browser_download_url);
  var httpOptions = {
    host: url.host,
    path: url.pathname,
    headers: {
      "User-Agent": repo.userAgent
    }
  };
  var inFlightDownloadPath = Nodepath.join(repo.globalStoragePath, inFlightDownloadFileName);
  var destPath = Nodepath.join(repo.globalStoragePath, target.saveAsFileName);
  var e = await Connection__Resolver__GitHub__Download$AgdaModeVscode.asFile(httpOptions, inFlightDownloadPath, callbacks.onDownload);
  var result;
  if (e.TAG === "Ok") {
    var e$1 = await rename(inFlightDownloadPath, inFlightDownloadPath + ".zip");
    if (e$1.TAG === "Ok") {
      await Connection__Resolver__GitHub__Unzip$AgdaModeVscode.run(inFlightDownloadPath + ".zip", destPath);
      var e$2 = await unlink(inFlightDownloadPath + ".zip");
      result = e$2.TAG === "Ok" ? ({
            TAG: "Ok",
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          }) : ({
            TAG: "Error",
            _0: {
              TAG: "CannotDeleteFile",
              _0: e$2._0,
              [Symbol.for("name")]: "CannotDeleteFile"
            },
            [Symbol.for("name")]: "Error"
          });
    } else {
      result = {
        TAG: "Error",
        _0: {
          TAG: "CannotRenameFile",
          _0: e$1._0,
          [Symbol.for("name")]: "CannotRenameFile"
        },
        [Symbol.for("name")]: "Error"
      };
    }
  } else {
    result = {
      TAG: "Error",
      _0: {
        TAG: "CannotDownload",
        _0: e._0,
        [Symbol.for("name")]: "CannotDownload"
      },
      [Symbol.for("name")]: "Error"
    };
  }
  if (result.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  }
  var remove = async function (path) {
    if (Nodefs.existsSync(path)) {
      await unlink(path);
      return ;
    }
    
  };
  await Promise.all([
        remove(inFlightDownloadPath),
        remove(inFlightDownloadPath + ".zip")
      ]);
  return {
          TAG: "Error",
          _0: result._0,
          [Symbol.for("name")]: "Error"
        };
}

function readTimestamp(memento) {
  return Core__Option.map(State__Type$AgdaModeVscode.Memento.get(memento, "alsReleaseCacheTimestamp"), (function (prim) {
                return new Date(prim);
              }));
}

function writeTimestamp(memento, timestamp) {
  return State__Type$AgdaModeVscode.Memento.set(memento, "alsReleaseCacheTimestamp", timestamp.toString());
}

function readReleaseCache(memento) {
  return State__Type$AgdaModeVscode.Memento.get(memento, "alsReleaseCache");
}

function writeReleaseCache(memento, releases) {
  return State__Type$AgdaModeVscode.Memento.set(memento, "alsReleaseCache", releases);
}

async function isValid(memento, cacheInvalidateExpirationSecs) {
  var timestamp = readTimestamp(memento);
  if (timestamp === undefined) {
    return false;
  }
  var currentTime = Date.now();
  var lastModifiedTime = Caml_option.valFromOption(timestamp).getTime();
  var diff = (currentTime - lastModifiedTime) / 1000.0 | 0;
  return diff < cacheInvalidateExpirationSecs;
}

async function get(memento) {
  var string = readReleaseCache(memento);
  if (string === undefined) {
    return {
            TAG: "Ok",
            _0: [],
            [Symbol.for("name")]: "Ok"
          };
  }
  var string$1 = Caml_option.valFromOption(string);
  var json;
  try {
    json = JSON.parse(string$1);
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotReadReleasesCache",
              _0: string$1,
              [Symbol.for("name")]: "CannotReadReleasesCache"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var e = decodeReleases(json);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0,
            [Symbol.for("name")]: "Error"
          };
  }
}

async function set(memento, releases) {
  var json = JSON.stringify(encodeReleases(releases));
  await writeTimestamp(memento, new Date());
  return await writeReleaseCache(memento, json);
}

async function getReleaseManifestFromGitHubRepo(repo) {
  var httpOptions = {
    host: "api.github.com",
    path: "/repos/" + repo.username + "/" + repo.repository + "/releases",
    headers: {
      "User-Agent": repo.userAgent
    }
  };
  var e = await Connection__Resolver__GitHub__Download$AgdaModeVscode.timeoutAfter(Connection__Resolver__GitHub__Download$AgdaModeVscode.asJson(httpOptions), 10000);
  if (e.TAG === "Ok") {
    return decodeReleases(e._0);
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotGetReleases",
              _0: e._0,
              [Symbol.for("name")]: "CannotGetReleases"
            },
            [Symbol.for("name")]: "Error"
          };
  }
}

async function getReleaseManifest(repo) {
  var isValid$1 = await isValid(repo.memento, repo.cacheInvalidateExpirationSecs);
  if (isValid$1) {
    var result = await get(repo.memento);
    return [
            result,
            true
          ];
  }
  var result$1 = await getReleaseManifestFromGitHubRepo(repo);
  if (result$1.TAG === "Ok") {
    await set(repo.memento, result$1._0);
  }
  return [
          result$1,
          false
        ];
}

async function get$1(repo, callbacks) {
  var ifIsDownloading = await isDownloading(repo.globalStoragePath);
  if (ifIsDownloading) {
    return {
            TAG: "Error",
            _0: "AlreadyDownloading",
            [Symbol.for("name")]: "Error"
          };
  }
  var match = await getReleaseManifest(repo);
  var error = match[0];
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: error._0,
            [Symbol.for("name")]: "Error"
          };
  }
  if (match[1]) {
    callbacks.log("Use cached release manifest");
  } else {
    callbacks.log("Cache invalidated, use fetched release manifest");
  }
  var target = callbacks.chooseFromReleases(error._0);
  if (target === undefined) {
    return {
            TAG: "Error",
            _0: "NoMatchingRelease",
            [Symbol.for("name")]: "Error"
          };
  }
  var destPath = Nodepath.join(repo.globalStoragePath, target.saveAsFileName);
  if (Nodefs.existsSync(destPath)) {
    callbacks.log("Used downloaded program at:" + destPath);
    return {
            TAG: "Ok",
            _0: [
              true,
              target
            ],
            [Symbol.for("name")]: "Ok"
          };
  }
  callbacks.log("Download from GitHub instead");
  var error$1 = await downloadLanguageServer(repo, callbacks, target);
  if (error$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              false,
              target
            ],
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: error$1._0,
            [Symbol.for("name")]: "Error"
          };
  }
}

var Module = {
  getReleaseManifest: getReleaseManifest,
  get: get$1
};

var Unzip;

var Download;

exports.Unzip = Unzip;
exports.Download = Download;
exports.Nd = Nd;
exports.$$Error = $$Error;
exports.Asset = Asset;
exports.Release = Release;
exports.Target = Target;
exports.chmodExecutable = chmodExecutable;
exports.Platform = Platform;
exports.Repo = Repo;
exports.Callbacks = Callbacks;
exports.Module = Module;
exports.getReleaseManifest = getReleaseManifest;
exports.get = get$1;
/* decode Not a pure module */
