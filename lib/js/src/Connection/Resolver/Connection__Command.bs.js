// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodeos = require("node:os");
var Js_string = require("rescript/lib/js/js_string.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Nodechild_process = require("node:child_process");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "Cannot find the executable on PATH";
  }
  switch (x.TAG) {
    case "NotSupported" :
        return "Path searching is not supported on \"" + x._0 + "\"";
    case "OnError" :
        return "Got error when looking for the executable: " + Util$AgdaModeVscode.JsError.toString(x._0);
    case "OnStderr" :
        return "Got something from the stderr when looking for the executable: " + x._0;
    
  }
}

var $$Error = {
  toString: toString
};

function searchWithCommand(command, name) {
  return new Promise((function (resolve, param) {
                Nodechild_process.exec(command + " " + name, {shell : true}, (function (error, stdout, stderr) {
                        Core__Option.forEach((error == null) ? undefined : Caml_option.some(error), (function (err) {
                                var isNotFound = Core__Option.mapOr(err.message, false, (function (a) {
                                        return Js_string.startsWith("Command failed: " + command + " " + name + "\n", a);
                                      }));
                                if (isNotFound) {
                                  return resolve({
                                              TAG: "Error",
                                              _0: "NotFound",
                                              [Symbol.for("name")]: "Error"
                                            });
                                } else {
                                  return resolve({
                                              TAG: "Error",
                                              _0: {
                                                TAG: "OnError",
                                                _0: err,
                                                [Symbol.for("name")]: "OnError"
                                              },
                                              [Symbol.for("name")]: "Error"
                                            });
                                }
                              }));
                        var stderr$1 = stderr.toString();
                        if (stderr$1 !== "") {
                          resolve({
                                TAG: "Error",
                                _0: {
                                  TAG: "OnStderr",
                                  _0: stderr$1,
                                  [Symbol.for("name")]: "OnStderr"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                        }
                        var stdout$1 = stdout.toString().trim();
                        if (stdout$1 === "" || stdout$1 === name + " not found") {
                          return resolve({
                                      TAG: "Error",
                                      _0: "NotFound",
                                      [Symbol.for("name")]: "Error"
                                    });
                        } else {
                          return resolve({
                                      TAG: "Ok",
                                      _0: stdout$1,
                                      [Symbol.for("name")]: "Ok"
                                    });
                        }
                      }));
              }));
}

function search(name, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  var timeout$1 = async function () {
    await Util$AgdaModeVscode.Promise_.$$setTimeout(timeout);
    return {
            TAG: "Error",
            _0: "NotFound",
            [Symbol.for("name")]: "Error"
          };
  };
  var search$1 = async function () {
    var os = Nodeos.type();
    switch (os) {
      case "Darwin" :
      case "Linux" :
          return await searchWithCommand("which", name);
      case "Windows_NT" :
          var stdout = await searchWithCommand("which", name);
          if (stdout.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: stdout._0,
                    [Symbol.for("name")]: "Ok"
                  };
          } else {
            return await searchWithCommand("where.exe", name);
          }
      default:
        return {
                TAG: "Error",
                _0: {
                  TAG: "NotSupported",
                  _0: os,
                  [Symbol.for("name")]: "NotSupported"
                },
                [Symbol.for("name")]: "Error"
              };
    }
  };
  return Promise.race([
              search$1(),
              timeout$1()
            ]);
}

exports.$$Error = $$Error;
exports.searchWithCommand = searchWithCommand;
exports.search = search;
/* node:os Not a pure module */
