// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Nodeos = require("node:os");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Chan$AgdaModeVscode = require("../../../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../../../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../../../Config.bs.js");
var Parser$AgdaModeVscode = require("../../../Parser/Parser.bs.js");
var Response$AgdaModeVscode = require("../../../Response.bs.js");
var Connection__Scheduler$AgdaModeVscode = require("../../Connection__Scheduler.bs.js");
var Connection__Target__Agda__Process$AgdaModeVscode = require("./Connection__Target__Agda__Process.bs.js");

async function make(path, args) {
  var $$process = Connection__Target__Agda__Process$AgdaModeVscode.make(path, ["--version"]);
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var destructor = Connection__Target__Agda__Process$AgdaModeVscode.onOutput($$process, (function (output) {
          switch (output.TAG) {
            case "Stdout" :
                var match_ = output._0.match(/Agda version (.*)/);
                if (match_ == null) {
                  return resolve({
                              TAG: "Error",
                              _0: "Cannot read Agda version",
                              [Symbol.for("name")]: "Error"
                            });
                }
                var match = match_[1];
                if (match === undefined) {
                  return resolve({
                              TAG: "Error",
                              _0: "Cannot read Agda version",
                              [Symbol.for("name")]: "Error"
                            });
                }
                var version = Caml_option.valFromOption(match);
                if (version !== undefined) {
                  return resolve({
                              TAG: "Ok",
                              _0: {
                                path: path,
                                args: args,
                                version: version
                              },
                              [Symbol.for("name")]: "Ok"
                            });
                } else {
                  return resolve({
                              TAG: "Error",
                              _0: "Cannot read Agda version",
                              [Symbol.for("name")]: "Error"
                            });
                }
            case "Stderr" :
                return resolve({
                            TAG: "Error",
                            _0: "Message from stderr when validating the program by running \"" + path + " --version\" :\n" + output._0,
                            [Symbol.for("name")]: "Error"
                          });
            case "Event" :
                return resolve({
                            TAG: "Error",
                            _0: "Something occured when validating the program:\n" + Connection__Target__Agda__Process$AgdaModeVscode.$$Event.toString(output._0),
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
  var result = await match[0];
  destructor();
  if (result.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "Validation",
              _0: result._0,
              [Symbol.for("name")]: "Validation"
            },
            [Symbol.for("name")]: "Error"
          };
  }
}

function toString(self) {
  var path = "* path: " + self.path;
  var args = "* args: " + Util$AgdaModeVscode.Pretty.array(self.args);
  var version = "* version: " + self.version;
  var os = "* platform: " + Nodeos.platform();
  return "## Parse Log\n" + (path + ("\n" + (args + ("\n" + (version + ("\n" + (os + "\n")))))));
}

var ProcInfo = {
  make: make,
  toString: toString
};

function destroy(self) {
  Chan$AgdaModeVscode.destroy(self.chan);
  self.encountedFirstPrompt = false;
  return Connection__Target__Agda__Process$AgdaModeVscode.destroy(self.process);
}

function wire(self) {
  var toResponse = function (extra) {
    return Curry._2(Parser$AgdaModeVscode.Incr.Gen.flatMap, (function (x) {
                  if (x.TAG === "Ok") {
                    var tokens = x._0;
                    if (tokens.TAG === "A" && tokens._0 === "Agda2>") {
                      return "Stop";
                    } else {
                      return {
                              TAG: "Yield",
                              _0: Response$AgdaModeVscode.Prioritized.parse(tokens),
                              [Symbol.for("name")]: "Yield"
                            };
                    }
                  }
                  var match = x._0;
                  return {
                          TAG: "Yield",
                          _0: {
                            TAG: "Error",
                            _0: {
                              TAG: "SExpression",
                              _0: match[0],
                              _1: match[1],
                              [Symbol.for("name")]: "SExpression"
                            },
                            [Symbol.for("name")]: "Error"
                          },
                          [Symbol.for("name")]: "Yield"
                        };
                }), extra);
  };
  var incrParser = Parser$AgdaModeVscode.SExpression.makeIncr(function (x) {
        var res = toResponse(x);
        if (typeof res !== "object") {
          if (self.encountedFirstPrompt) {
            return Chan$AgdaModeVscode.emit(self.chan, {
                        TAG: "Ok",
                        _0: "Stop",
                        [Symbol.for("name")]: "Ok"
                      });
          } else {
            self.encountedFirstPrompt = true;
            return ;
          }
        }
        var response = res._0;
        if (response.TAG === "Ok") {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: "Ok",
                      _0: {
                        TAG: "Yield",
                        _0: response._0,
                        [Symbol.for("name")]: "Yield"
                      },
                      [Symbol.for("name")]: "Ok"
                    });
        } else {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: "Error",
                      _0: {
                        TAG: "ResponseParseError",
                        _0: response._0,
                        [Symbol.for("name")]: "ResponseParseError"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }
      });
  var listenerHandle;
  listenerHandle = Connection__Target__Agda__Process$AgdaModeVscode.onOutput(self.process, (function (x) {
          switch (x.TAG) {
            case "Stdout" :
                var rawText = x._0;
                if (rawText.startsWith("Error:")) {
                  return Chan$AgdaModeVscode.emit(self.chan, {
                              TAG: "Error",
                              _0: {
                                TAG: "AgdaError",
                                _0: rawText,
                                [Symbol.for("name")]: "AgdaError"
                              },
                              [Symbol.for("name")]: "Error"
                            });
                } else {
                  Parser$AgdaModeVscode.splitToLines(rawText).forEach(function (extra) {
                        return Parser$AgdaModeVscode.Incr.feed(incrParser, extra);
                      });
                  return ;
                }
            case "Stderr" :
                return Chan$AgdaModeVscode.emit(self.chan, {
                            TAG: "Error",
                            _0: {
                              TAG: "AgdaError",
                              _0: x._0,
                              [Symbol.for("name")]: "AgdaError"
                            },
                            [Symbol.for("name")]: "Error"
                          });
            case "Event" :
                return Chan$AgdaModeVscode.emit(self.chan, {
                            TAG: "Error",
                            _0: {
                              TAG: "Process",
                              _0: x._0,
                              [Symbol.for("name")]: "Process"
                            },
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
}

async function make$1(method) {
  if (method.TAG !== "ViaPipe") {
    return {
            TAG: "Error",
            _0: "ConnectionViaTCPNotSupported",
            [Symbol.for("name")]: "Error"
          };
  }
  var args = ["--interaction"].concat(Config$AgdaModeVscode.Connection.getCommandLineOptions());
  var e = await make(method._0, args);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0,
            [Symbol.for("name")]: "Error"
          };
  }
  var procInfo = e._0;
  var conn = {
    procInfo: procInfo,
    process: Connection__Target__Agda__Process$AgdaModeVscode.make(procInfo.path, procInfo.args),
    chan: Chan$AgdaModeVscode.make(),
    encountedFirstPrompt: false
  };
  wire(conn);
  return {
          TAG: "Ok",
          _0: conn,
          [Symbol.for("name")]: "Ok"
        };
}

async function onResponse(conn, callback) {
  var scheduler = Connection__Scheduler$AgdaModeVscode.make();
  var match = Util$AgdaModeVscode.Promise_.pending();
  var stopResponseListener = match[1];
  var listener = function (x) {
    if (x.TAG !== "Ok") {
      return stopResponseListener({
                  TAG: "Error",
                  _0: x._0,
                  [Symbol.for("name")]: "Error"
                });
    }
    var match = x._0;
    if (typeof match !== "object") {
      Connection__Scheduler$AgdaModeVscode.runLast(scheduler, (function (response) {
                return callback(response);
              })).finally(function () {
            stopResponseListener({
                  TAG: "Ok",
                  _0: undefined,
                  [Symbol.for("name")]: "Ok"
                });
          });
      return ;
    }
    var response = match._0;
    if (response.TAG === "NonLast") {
      return Connection__Scheduler$AgdaModeVscode.runNonLast(scheduler, (function (response) {
                    return callback(response);
                  }), response._0);
    } else {
      return Connection__Scheduler$AgdaModeVscode.addLast(scheduler, response._0, response._1);
    }
  };
  var listenerHandle;
  listenerHandle = Chan$AgdaModeVscode.on(conn.chan, listener);
  var result = await match[0];
  Core__Option.forEach(listenerHandle, (function (destroyListener) {
          destroyListener();
        }));
  return result;
}

function sendRequest(conn, request, handler) {
  var promise = onResponse(conn, handler);
  Connection__Target__Agda__Process$AgdaModeVscode.send(conn.process, request);
  return promise;
}

function getInfo(conn) {
  return [
          conn.procInfo.version,
          conn.procInfo.path
        ];
}

var Module = {
  make: make$1,
  destroy: destroy,
  sendRequest: sendRequest,
  getInfo: getInfo
};

var $$Error;

var $$Scheduler;

var Process;

exports.$$Error = $$Error;
exports.$$Scheduler = $$Scheduler;
exports.Process = Process;
exports.ProcInfo = ProcInfo;
exports.Module = Module;
exports.make = make$1;
exports.destroy = destroy;
exports.sendRequest = sendRequest;
exports.getInfo = getInfo;
/* node:os Not a pure module */
