// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var State__Type$AgdaModeVscode = require("../State/State__Type.bs.js");
var Connection__URI$AgdaModeVscode = require("./Connection__URI.bs.js");
var Connection__Resolver$AgdaModeVscode = require("./Connection__Resolver.bs.js");
var Connection__Validation$AgdaModeVscode = require("./Connection__Validation.bs.js");
var Connection__Resolver__GitHub$AgdaModeVscode = require("./Resolver/Connection__Resolver__GitHub.bs.js");

async function tryAgda() {
  var storedPaths = Config$AgdaModeVscode.Connection.getAgdaPaths();
  var storedName = Config$AgdaModeVscode.Connection.getAgdaVersion();
  var paths = storedPaths.map(function (path) {
        return {
                TAG: "FromFile",
                _0: path,
                [Symbol.for("name")]: "FromFile"
              };
      });
  return await Connection__Resolver$AgdaModeVscode.searchMany([
                paths,
                [{
                    TAG: "FromCommand",
                    _0: storedName,
                    [Symbol.for("name")]: "FromCommand"
                  }]
              ].flat());
}

function getRawPathsFromConfig() {
  return Config$AgdaModeVscode.Connection.getAgdaPaths();
}

async function fromFilepath(rawPath) {
  var match = await Connection__URI$AgdaModeVscode.parse(rawPath);
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotResolvePath",
              _0: rawPath,
              [Symbol.for("name")]: "CannotResolvePath"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  if (match.TAG !== "Filepath") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotResolvePath",
              _0: match._0.toString(),
              [Symbol.for("name")]: "CannotResolvePath"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var path = match._0;
  var result = await Connection__Validation$AgdaModeVscode.run(path, ["--version"], (function (output) {
          return {
                  TAG: "Ok",
                  _0: output,
                  [Symbol.for("name")]: "Ok"
                };
        }));
  if (result.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "ValidationError",
              _0: path,
              _1: result._0,
              [Symbol.for("name")]: "ValidationError"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var output = result._0;
  var match$1 = output.match(/Agda version (.*)/);
  if (!(match$1 == null) && match$1.length === 2) {
    var version = match$1[1];
    if (version !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                TAG: "Agda",
                _0: version,
                _1: path,
                [Symbol.for("name")]: "Agda"
              },
              [Symbol.for("name")]: "Ok"
            };
    }
    
  }
  var match$2 = output.match(/Agda v(.*) Language Server v(.*)/);
  if (match$2 == null) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  if (match$2.length !== 3) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var agdaVersion = match$2[1];
  if (agdaVersion === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var alsVersion = match$2[2];
  if (alsVersion !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              TAG: "ALS",
              _0: alsVersion,
              _1: agdaVersion,
              _2: {
                TAG: "Error",
                _0: path,
                [Symbol.for("name")]: "Error"
              },
              [Symbol.for("name")]: "ALS"
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
}

function getPath(target) {
  if (target.TAG === "Agda") {
    return target._1;
  }
  var path = target._2;
  if (path.TAG !== "Ok") {
    return path._0;
  }
  var match = path._0;
  if (match.TAG === "ViaPipe") {
    return match._0;
  } else {
    return match._0.toString();
  }
}

function getAllFromConfig() {
  return Promise.all(Config$AgdaModeVscode.Connection.getAgdaPaths().map(fromFilepath));
}

async function getFirstUsable() {
  var targets = await getAllFromConfig();
  return Core__Array.reduce(targets, undefined, (function (acc, target) {
                if (acc !== undefined) {
                  return acc;
                } else if (target.TAG === "Ok") {
                  return target._0;
                } else {
                  return ;
                }
              }));
}

async function getPicked(state) {
  var fromMemento = State__Type$AgdaModeVscode.Memento.get(state.memento, "pickedConnection");
  if (fromMemento === undefined) {
    return await getFirstUsable();
  }
  var fromMemento$1 = Caml_option.valFromOption(fromMemento);
  var fromConfig = await getAllFromConfig();
  var stillExists = Core__Array.reduce(fromConfig, false, (function (acc, target) {
          if (acc) {
            return true;
          } else if (target.TAG === "Ok") {
            return getPath(target._0) === fromMemento$1;
          } else {
            return false;
          }
        }));
  if (stillExists) {
    var target = await fromFilepath(fromMemento$1);
    if (target.TAG === "Ok") {
      return target._0;
    } else {
      return ;
    }
  }
  await State__Type$AgdaModeVscode.Memento.set(state.memento, "pickedConnection", undefined);
}

function setPicked(state, target) {
  if (target !== undefined) {
    return State__Type$AgdaModeVscode.Memento.set(state.memento, "pickedConnection", getPath(target));
  } else {
    return State__Type$AgdaModeVscode.Memento.set(state.memento, "pickedConnection", undefined);
  }
}

var Module = {
  tryAgda: tryAgda,
  getRawPathsFromConfig: getRawPathsFromConfig,
  fromFilepath: fromFilepath,
  getPath: getPath,
  getAllFromConfig: getAllFromConfig,
  getPicked: getPicked,
  setPicked: setPicked
};

var Resolver;

var IPC;

var $$Error;

var URI;

exports.Resolver = Resolver;
exports.IPC = IPC;
exports.$$Error = $$Error;
exports.URI = URI;
exports.Module = Module;
exports.tryAgda = tryAgda;
exports.getRawPathsFromConfig = getRawPathsFromConfig;
exports.fromFilepath = fromFilepath;
exports.getPath = getPath;
exports.getAllFromConfig = getAllFromConfig;
exports.getPicked = getPicked;
exports.setPicked = setPicked;
/* Config-AgdaModeVscode Not a pure module */
