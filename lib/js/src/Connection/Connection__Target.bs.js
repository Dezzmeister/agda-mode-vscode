// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodeos = require("node:os");
var Nodeurl = require("node:url");
var Nodepath = require("node:path");
var Untildify = require("untildify");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Connection__Resolver$AgdaModeVscode = require("./Connection__Resolver.bs.js");
var Connection__Resolver__GitHub$AgdaModeVscode = require("./Resolver/Connection__Resolver__GitHub.bs.js");
var Connection__Target__Agda__Process$AgdaModeVscode = require("./Target/Agda/Connection__Target__Agda__Process.bs.js");

async function afterDownload(isCached, param) {
  var path = param[0];
  var assetPath = Nodepath.join(path, "data");
  var env = Object.fromEntries([[
          "Agda_datadir",
          assetPath
        ]]);
  var options_env = env;
  var options = {
    env: options_env
  };
  var execPath = Nodepath.join(path, "als");
  var shouldChmod = !isCached && Nodeos.platform() !== "win32";
  if (shouldChmod) {
    await Connection__Resolver__GitHub$AgdaModeVscode.chmodExecutable(execPath);
  }
  return {
          TAG: "Ok",
          _0: [
            execPath,
            [],
            options,
            param[1]
          ],
          [Symbol.for("name")]: "Ok"
        };
}

function chooseFromReleases(releases) {
  var match = Nodeos.platform();
  var platform;
  switch (match) {
    case "darwin" :
        var match$1 = Nodeos.arch();
        switch (match$1) {
          case "arm64" :
              platform = "macos-arm64";
              break;
          case "x64" :
              platform = "macos-x64";
              break;
          default:
            platform = undefined;
        }
        break;
    case "linux" :
        platform = "ubuntu";
        break;
    case "win32" :
        platform = "windows";
        break;
    default:
      platform = undefined;
  }
  var release = Connection__Resolver__GitHub$AgdaModeVscode.Release.chooseLatest(releases);
  if (release === undefined) {
    return ;
  }
  if (platform === undefined) {
    return ;
  }
  var expectedAssetName = "als-Agda-2.7.0.1-" + platform + ".zip";
  var asset = Connection__Resolver__GitHub$AgdaModeVscode.Asset.chooseByName(release.assets, expectedAssetName);
  if (asset !== undefined) {
    return {
            release: release,
            asset: asset,
            saveAsFileName: release.tag_name + "-" + platform
          };
  }
  
}

function makeAgdaLanguageServerRepo(globalStoragePath) {
  return {
          username: "agda",
          repository: "agda-language-server",
          userAgent: "agda/agda-mode-vscode",
          globalStoragePath: globalStoragePath,
          cacheInvalidateExpirationSecs: 86400
        };
}

async function probeFilepath(path) {
  var result = await Connection__Target__Agda__Process$AgdaModeVscode.Validation.run(path, ["--version"], (function (output) {
          return {
                  TAG: "Ok",
                  _0: output,
                  [Symbol.for("name")]: "Ok"
                };
        }));
  if (result.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "Agda",
              _0: {
                TAG: "Validation",
                _0: Connection__Target__Agda__Process$AgdaModeVscode.Validation.$$Error.toString(result._0),
                [Symbol.for("name")]: "Validation"
              },
              [Symbol.for("name")]: "Agda"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var output = result._0;
  var match = output.match(/Agda version (.*)/);
  if (!(match == null) && match.length === 2) {
    var version = match[1];
    if (version !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                TAG: "Agda",
                _0: version,
                _1: path,
                [Symbol.for("name")]: "Agda"
              },
              [Symbol.for("name")]: "Ok"
            };
    }
    
  }
  var match$1 = output.match(/Agda v(.*) Language Server v(.*)/);
  if (match$1 == null) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  if (match$1.length !== 3) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var agdaVersion = match$1[1];
  if (agdaVersion === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var alsVersion = match$1[2];
  if (alsVersion !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              TAG: "ALS",
              _0: alsVersion,
              _1: agdaVersion,
              _2: {
                TAG: "Error",
                _0: path,
                [Symbol.for("name")]: "Error"
              },
              [Symbol.for("name")]: "ALS"
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: path,
              [Symbol.for("name")]: "NotAgdaOrALS"
            },
            [Symbol.for("name")]: "Error"
          };
  }
}

async function resolvePath(path) {
  var result;
  try {
    result = new Nodeurl.URL(path);
  }
  catch (exn){
    result = undefined;
  }
  if (result !== undefined) {
    if (result.protocol === "lsp:") {
      return {
              TAG: "URL",
              _0: result,
              [Symbol.for("name")]: "URL"
            };
    } else {
      return ;
    }
  }
  var path$1 = Untildify(path);
  var path$2 = Nodepath.normalize(path$1);
  return {
          TAG: "Filepath",
          _0: path$2,
          [Symbol.for("name")]: "Filepath"
        };
}

async function tryALS(globalStoragePath, onDownload) {
  var port = Config$AgdaModeVscode.Connection.getAgdaLanguageServerPort();
  var result = await Connection__Resolver$AgdaModeVscode.searchMany([
        {
          TAG: "FromTCP",
          _0: port,
          _1: "localhost",
          [Symbol.for("name")]: "FromTCP"
        },
        {
          TAG: "FromCommand",
          _0: "als",
          [Symbol.for("name")]: "FromCommand"
        },
        {
          TAG: "FromGitHub",
          _0: makeAgdaLanguageServerRepo(globalStoragePath),
          _1: {
            chooseFromReleases: chooseFromReleases,
            onDownload: onDownload,
            afterDownload: afterDownload,
            log: (function (x) {
                console.log(x);
              })
          },
          [Symbol.for("name")]: "FromGitHub"
        }
      ]);
  var method = result[0];
  if (method !== undefined && method.TAG === "ViaPipe") {
    await Config$AgdaModeVscode.Connection.addAgdaPath(method._0);
  }
  return result;
}

async function tryAgda() {
  var storedPaths = Config$AgdaModeVscode.Connection.getAgdaPaths();
  var storedName = Config$AgdaModeVscode.Connection.getAgdaVersion();
  var paths = storedPaths.map(function (path) {
        return {
                TAG: "FromFile",
                _0: path,
                [Symbol.for("name")]: "FromFile"
              };
      });
  var result = await Connection__Resolver$AgdaModeVscode.searchMany([
          paths,
          [{
              TAG: "FromCommand",
              _0: storedName,
              [Symbol.for("name")]: "FromCommand"
            }]
        ].flat());
  var method = result[0];
  if (method !== undefined && method.TAG === "ViaPipe") {
    await Config$AgdaModeVscode.Connection.addAgdaPath(method._0);
  }
  return result;
}

function getRawPathsFromConfig() {
  return Config$AgdaModeVscode.Connection.getAgdaPaths();
}

async function probePath(rawPath) {
  var match = await resolvePath(rawPath);
  if (match !== undefined) {
    if (match.TAG === "Filepath") {
      return await probeFilepath(match._0);
    } else {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotResolvePath",
                _0: match._0.toString(),
                [Symbol.for("name")]: "CannotResolvePath"
              },
              [Symbol.for("name")]: "Error"
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotResolvePath",
              _0: rawPath,
              [Symbol.for("name")]: "CannotResolvePath"
            },
            [Symbol.for("name")]: "Error"
          };
  }
}

var Module = {
  tryALS: tryALS,
  tryAgda: tryAgda,
  getRawPathsFromConfig: getRawPathsFromConfig,
  probePath: probePath
};

var Resolver;

var IPC;

var $$Error;

exports.Resolver = Resolver;
exports.IPC = IPC;
exports.$$Error = $$Error;
exports.Module = Module;
exports.tryALS = tryALS;
exports.tryAgda = tryAgda;
exports.getRawPathsFromConfig = getRawPathsFromConfig;
exports.probePath = probePath;
/* node:os Not a pure module */
