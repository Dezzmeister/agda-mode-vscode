// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodefs = require("node:fs");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var State__Memento$AgdaModeVscode = require("../State/State__Memento.bs.js");
var Connection__URI$AgdaModeVscode = require("./Connection__URI.bs.js");
var Connection__Validation$AgdaModeVscode = require("./Connection__Validation.bs.js");

async function fromURI(uri) {
  if (uri.TAG !== "Filepath") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotHandleURLsATM",
              _0: Connection__URI$AgdaModeVscode.toString(uri),
              [Symbol.for("name")]: "CannotHandleURLsATM"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var path = uri._0;
  var result = await Connection__Validation$AgdaModeVscode.run3(path, ["--version"]);
  if (result.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "ValidationError",
              _0: path,
              _1: result._0,
              [Symbol.for("name")]: "ValidationError"
            },
            [Symbol.for("name")]: "Error"
          };
  }
  var output = result._0;
  var match = output.match(/Agda version (.*)/);
  var exit = 0;
  if ((match == null) || match.length !== 2) {
    exit = 1;
  } else {
    var version = match[1];
    if (version !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                TAG: "Agda",
                _0: version,
                _1: path,
                [Symbol.for("name")]: "Agda"
              },
              [Symbol.for("name")]: "Ok"
            };
    }
    exit = 1;
  }
  if (exit === 1) {
    var match$1 = output.match(/Agda v(.*) Language Server v(.*)/);
    var exit$1 = 0;
    if ((match$1 == null) || match$1.length !== 3) {
      exit$1 = 2;
    } else {
      var agdaVersion = match$1[1];
      if (agdaVersion !== undefined) {
        var alsVersion = match$1[2];
        if (alsVersion !== undefined) {
          var prebuildDataDirPath = Nodepath.join(path, "..", "data");
          var isPrebuilt;
          try {
            await Nodefs.promises.access(prebuildDataDirPath);
            isPrebuilt = true;
          }
          catch (exn){
            isPrebuilt = false;
          }
          var lspOptions;
          if (isPrebuilt) {
            var assetPath = Nodepath.join(path, "..", "data");
            var env = Object.fromEntries([[
                    "Agda_datadir",
                    assetPath
                  ]]);
            lspOptions = {
              env: env
            };
          } else {
            lspOptions = undefined;
          }
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ALS",
                    _0: alsVersion,
                    _1: agdaVersion,
                    _2: {
                      TAG: "Ok",
                      _0: {
                        TAG: "ViaPipe",
                        _0: path,
                        _1: [],
                        _2: lspOptions,
                        _3: {
                          TAG: "FromFile",
                          _0: path,
                          [Symbol.for("name")]: "FromFile"
                        },
                        [Symbol.for("name")]: "ViaPipe"
                      },
                      [Symbol.for("name")]: "Ok"
                    },
                    [Symbol.for("name")]: "ALS"
                  },
                  [Symbol.for("name")]: "Ok"
                };
        }
        exit$1 = 2;
      } else {
        exit$1 = 2;
      }
    }
    if (exit$1 === 2) {
      console.log("output of NotAgdaOrALS: " + output);
      return {
              TAG: "Error",
              _0: {
                TAG: "NotAgdaOrALS",
                _0: path,
                [Symbol.for("name")]: "NotAgdaOrALS"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    
  }
  
}

async function fromRawPath(rawPath) {
  var uri = Connection__URI$AgdaModeVscode.parse(rawPath);
  return await fromURI(uri);
}

function fromRawPaths(paths) {
  return Promise.all(paths.map(fromRawPath));
}

function fromURIs(uris) {
  return Promise.all(uris.map(fromURI));
}

function toURI(target) {
  if (target.TAG === "Agda") {
    return {
            TAG: "Filepath",
            _0: target._1,
            [Symbol.for("name")]: "Filepath"
          };
  }
  var path = target._2;
  if (path.TAG !== "Ok") {
    return {
            TAG: "Filepath",
            _0: path._0,
            [Symbol.for("name")]: "Filepath"
          };
  }
  var match = path._0;
  if (match.TAG === "ViaPipe") {
    return {
            TAG: "Filepath",
            _0: match._0,
            [Symbol.for("name")]: "Filepath"
          };
  } else {
    return {
            TAG: "URL",
            _0: match._0,
            [Symbol.for("name")]: "URL"
          };
  }
}

async function getPicked(memento, rawSuppliedPaths) {
  var match = Util$AgdaModeVscode.Result.partition(await Promise.all(rawSuppliedPaths.map(fromURI)));
  var suppliedTargets = match[0];
  var target = suppliedTargets[0];
  var pickFromSuppliedTargetsInstead = target !== undefined ? ({
        TAG: "Ok",
        _0: target,
        [Symbol.for("name")]: "Ok"
      }) : ({
        TAG: "Error",
        _0: match[1],
        [Symbol.for("name")]: "Error"
      });
  var rawPathFromMemento = State__Memento$AgdaModeVscode.get(memento, "pickedConnection");
  if (rawPathFromMemento === undefined) {
    return pickFromSuppliedTargetsInstead;
  }
  var targetFromMemento = await fromRawPath(Caml_option.valFromOption(rawPathFromMemento));
  if (targetFromMemento.TAG === "Ok") {
    var targetFromMemento$1 = targetFromMemento._0;
    var existsInSuppliedTargets = Util$AgdaModeVscode.$$Array.includes(suppliedTargets, targetFromMemento$1);
    if (existsInSuppliedTargets) {
      return {
              TAG: "Ok",
              _0: targetFromMemento$1,
              [Symbol.for("name")]: "Ok"
            };
    } else {
      await State__Memento$AgdaModeVscode.set(memento, "pickedConnection", undefined);
      return pickFromSuppliedTargetsInstead;
    }
  }
  await State__Memento$AgdaModeVscode.set(memento, "pickedConnection", undefined);
  return pickFromSuppliedTargetsInstead;
}

function setPicked(memento, target) {
  if (target !== undefined) {
    return State__Memento$AgdaModeVscode.set(memento, "pickedConnection", Connection__URI$AgdaModeVscode.toString(toURI(target)));
  } else {
    return State__Memento$AgdaModeVscode.set(memento, "pickedConnection", undefined);
  }
}

var Module = {
  fromURI: fromURI,
  fromURIs: fromURIs,
  toURI: toURI,
  fromRawPath: fromRawPath,
  fromRawPaths: fromRawPaths,
  getPicked: getPicked,
  setPicked: setPicked
};

var IPC;

var $$Error;

var URI;

var Process;

exports.IPC = IPC;
exports.$$Error = $$Error;
exports.URI = URI;
exports.Process = Process;
exports.Module = Module;
exports.fromURI = fromURI;
exports.fromURIs = fromURIs;
exports.toURI = toURI;
exports.fromRawPath = fromRawPath;
exports.fromRawPaths = fromRawPaths;
exports.getPicked = getPicked;
exports.setPicked = setPicked;
/* node:fs Not a pure module */
